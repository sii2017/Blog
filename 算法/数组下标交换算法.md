## 数组下标交换算法
在相关面试题中偶遇一道题目   
> 有1,2,....一直到n的无序数组,求排序算法,并且要求时间复杂度为O(n),空间复杂度O(1),使用交换,而且一次只能交换两个数。   
   
看到以后吃了一惊，心想目前我了解的算法中最快的也就nlogn，哪里来的n的速度。  
仔细揣摩了一下后，发现这道题是有限定的：数字是连续的，数字是唯一的。    
因此这样就可以通过数组下标交换的方式来进行快速的，效率达到O(n)的排序。   
### 代码思路
由于整体数字都是连续的且唯一的，所以意味着有一个pos就对应着一个相同的数字减一。   
比如：   
5 2 3 1 4   
而其pos为0 1 2 3 4   
我们通过遍历，先得到第一个值arr[i]，为5。   
然后我们将该值与位置（5-1）的值交换。   
4 2 3 1 5   
我们并不继续遍历，我们仍然处理这个值，当前arr[i]，为4   
然后与位置（4-1）的值进行交换。    
1 2 3 4 5    
当当前的值减一等于i，那么我们再遍历到下一个数。   
### 代码内容
```c
int arr[] = { 9,8,7,6,5,1,4,2,3 };   

int size = sizeof(arr) / sizeof(int);   
for (int i = 0; i < size; )  
{   
	int temp = arr[arr[i] - 1];  
	arr[arr[i] - 1] = arr[i];  
	arr[i] = temp;   

	if (arr[i] == i + 1)   
		i++;  
}  
```   
需要注意的是，直到当前值减一与i相等，才进行下一次遍历。这是因为光遍历一次无法将值位置全部换对，需要对当前值进行多次的遍历才行。    