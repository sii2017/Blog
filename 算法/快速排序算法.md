## 快速排序算法
快速排序由C. A. R. Hoare在1962年提出。  
它的基本思想是：通过一趟排序将需要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。    
### 快速排序演示
### 例子
```c   
#include <iostream>     
using namespace std;   

void QuickSort(int* num, int beg, int end)   
{    
	int key = num[beg];	//key值默认为数组首个数字   
	int i = beg;	//保存原始位置，beg和end将会进行自增自减操作   
	int j = end;  
	while (beg < end)   
	{    
		while (num[end] >= key && beg<end)	//从后往前找，比key大或者相等的为正常   
			end--;  
		//找到了比key小的则与key交换位置   
		//先将原本是key的位置（第一个）替换成新找到的更小的num[end]，然后将较大的key赋值给num[end]，完成交替   
		num[beg] = num[end];	  
		num[end] = key;     

		while (num[beg] <= key && beg<end)	//从前往后找，比key小或相等的为正常    
			beg++;   
		//找到了比key大的则与key交换位置   
		//先将原本是key的位置（key[end])替换成新找到的更大的num[beg]，然后将较小的key赋值给num[beg]，完成交替     
		num[end] = num[beg];   
		num[beg] = key;   
	}   

	//如果初始位置与自增自减后的位置之间没有数字，则不进行递归。    
	//此时end和beg应该为同一个数字，且num[beg]和num[end]都是已经位置正确的key值，以key值为界限，另外将前半段和后半段进行排序    
	if (i < beg - 1)   
		QuickSort(num, i, beg - 1);   
	if(end + 1 < j)   
		QuickSort(num, end + 1, j);   
}    

int main()   
{   
	int tobesort[14] = { 23,1,3,45,5,7,8,9,2,12,54,2,-1,24 };   
	QuickSort(tobesort, 0, 13);   

	for (int i = 0; i < 13; i++)   
		cout << tobesort[i] << " ";   
	cout << endl;   

	getchar();   
	return 0;   
}   
```   