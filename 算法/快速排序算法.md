## 快速排序算法
快速排序由C. A. R. Hoare在1962年提出。  
它的基本思想是：通过一趟排序将需要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。    
### 快速排序演示
需要排序的数组：6  1  27  9  3  4  5  10  8   
**1 首先指定最左边的第一个数字为关键数据。**   
**2 通过2.1和2.2的循环，将关键数字与数组里所有的数字进行比较，最终将他放到正确的位置，使关键数字左边的数字都比其小，关键数字右边的数字都比其大。**   
**2.1 首先从右往左将每个数字与关键数据比较，如果他们比关键数据大或相等，则为正常情况，并不处理他们。直到找到第一个比关键数据小的数据，将其与关键数据进行位置交换。**   
2.2 然后从左往右将每个数字与关键数据比较，如果他们比关键数据小或相等，则为正常情况，并不处理他们。直到找到第一个比关键数据大的数据，将其与关键数据进行位置交换。   
3 将数组分为两段，关键数据前的数组与关键数据后的数组，各自再进行递归，来重复1和2的过程，直到数组中的所有数据都进行排序。   
### 例子
```c   
#include <iostream>     
using namespace std;   

void QuickSort(int* num, int beg, int end)   
{    
	int key = num[beg];	//key值默认为数组首个数字   
	int i = beg;	//保存原始位置，beg和end将会进行自增自减操作   
	int j = end;  
	while (beg < end)   
	{    
		while (num[end] >= key && beg<end)	//从后往前找，比key大或者相等的为正常   
			end--;  
		//找到了比key小的则与key交换位置   
		//先将原本是key的位置（第一个）替换成新找到的更小的num[end]，然后将较大的key赋值给num[end]，完成交替   
		num[beg] = num[end];	  
		num[end] = key;     

		while (num[beg] <= key && beg<end)	//从前往后找，比key小或相等的为正常    
			beg++;   
		//找到了比key大的则与key交换位置   
		//先将原本是key的位置（key[end])替换成新找到的更大的num[beg]，然后将较小的key赋值给num[beg]，完成交替     
		num[end] = num[beg];   
		num[beg] = key;   
	}   

	//如果初始位置与自增自减后的位置之间没有数字，则不进行递归。    
	//此时end和beg应该为同一个数字，且num[beg]和num[end]都是已经位置正确的key值，以key值为界限，另外将前半段和后半段进行排序    
	if (i < beg - 1)   
		QuickSort(num, i, beg - 1);   
	if(end + 1 < j)   
		QuickSort(num, end + 1, j);   
}    

int main()   
{   
	int tobesort[14] = { 23,1,3,45,5,7,8,9,2,12,54,2,-1,24 };   
	QuickSort(tobesort, 0, 13);   

	for (int i = 0; i < 13; i++)   
		cout << tobesort[i] << " ";   
	cout << endl;   

	getchar();   
	return 0;   
}   
```   