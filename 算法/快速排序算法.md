## 快速排序算法
快速排序算法是一种**不稳定**算法。    
快速排序由C. A. R. Hoare在1962年提出。  
它的基本思想是：    
通过一趟排序将需要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小。    
然后再按此方法对这两部分数据分别进行快速排序（以递归为方式，以分治为思想）。    
通过数次分治的排序，则数组中所有的数据皆排序完成了。      
### 解法1
需要排序的数组：6  1  27  9  3  4  5  10  8   
设定为以下:  
```c
int key= num[0];	//将第一个数字设为关键数据   
int beg= 0;   //从前往后走的数组下标   
int end= 8;	  //从后往前走的数组下标    
```   
1 首先指定最左边的第一个数字为关键数据。   
2 通过2.1和2.2的循环，将关键数字与数组里所有的数字进行比较，最终将他放到正确的位置，使关键数字左边的数字都比其小，关键数字右边的数字都比其大。   
2.1 首先从右往左将每个数字与关键数据比较，如果他们比关键数据大或相等，则为正常情况，并不处理他们。直到找到第一个比关键数据小的数据，将其与关键数据进行位置交换。   
2.2 然后从左往右将每个数字与关键数据比较，如果他们比关键数据小或相等，则为正常情况，并不处理他们。直到找到第一个比关键数据大的数据，将其与关键数据进行位置交换。   
2.3 当两个数组下标beg与end相遇（即他们相等），则结束这次循环，并且完成了首次排序，此时关键数据应该已经到了正确的位置。   
3 将数组分为两段，关键数据前的数组与关键数据后的数组，各自再进行递归，来重复1和2的过程，直到数组中的所有数据都进行排序。   
### 范例代码
```c   
#include <iostream>     
using namespace std;   

void QuickSort(int* num, int beg, int end)   
{    
	int key = num[beg];	//key值默认为数组首个数字   
	int i = beg;	//保存原始位置，beg和end将会进行自增自减操作   
	int j = end;  
	while (beg < end)   
	{    
		while (num[end] >= key && beg<end)	//从后往前找，比key大或者相等的为正常   
			end--;  
		//找到了比key小的则与key交换位置   
		//先将原本是key的位置（第一个）替换成新找到的更小的num[end]，然后将较大的key赋值给num[end]，完成交替   
		num[beg] = num[end];	  
		num[end] = key;     

		while (num[beg] <= key && beg<end)	//从前往后找，比key小或相等的为正常    
			beg++;   
		//找到了比key大的则与key交换位置   
		//先将原本是key的位置（key[end])替换成新找到的更大的num[beg]，然后将较小的key赋值给num[beg]，完成交替     
		num[end] = num[beg];   
		num[beg] = key;   
	}   

	//如果初始位置与自增自减后的位置之间没有数字，则不进行递归。    
	//此时end和beg应该为同一个数字，且num[beg]和num[end]都是已经位置正确的key值，以key值为界限，另外将前半段和后半段进行排序    
	if (i < beg - 1)   
		QuickSort(num, i, beg - 1);   
	if(end + 1 < j)   
		QuickSort(num, end + 1, j);   
}    

int main()   
{   
	int tobesort[14] = { 23,1,3,45,5,7,8,9,2,12,54,2,-1,24 };   
	QuickSort(tobesort, 0, 13);   

	for (int i = 0; i < 13; i++)   
		cout << tobesort[i] << " ";   
	cout << endl;   

	getchar();   
	return 0;   
}   
```   
### 解法2   
**解法2与解法1的区别在于过程2中排列数据的方式。**     
需要排序的数组：6  1  27  9  3  4  5  10  8   
设定为以下:  
```c
int key= num[0];	//将第一个数字设为关键数据   
int beg= 0;   //从前往后走的数组下标   
int end= 8;	  //从后往前走的数组下标    
```   
1 首先指定最左边的第一个数字为关键数据。   
2 通过2.1和2.2的循环，将关键数字与数组里所有的数字进行比较，最终将他放到正确的位置，使关键数字左边的数字都比其小，关键数字右边的数字都比其大。   
**2.1 首先从右往左将每个数字与关键数据比较，如果他们比关键数据大或相等，则为正常情况，并不处理他们。直到找到第一个比关键数据小的数据，暂不处理，记住该位置。   
2.2 然后从左往右将每个数字与关键数据比较，如果他们比关键数据小或相等，则为正常情况，并不处理他们。直到找到第一个比关键数据大的数据，暂不处理，记住该位置。   
2.3 将2.1和2.2的两个代处理的数据相互交换位置。   
2.4 当两个数组下标相遇即相等，则将该下标的数据与关键数据相交换。即完成首次排序。**    
> 第一次考虑这里时有所疑问：关键数据在第一个位置，如果相遇时的数字小于关键数据，那么交换是没有问题的，如果大于关键数据，那么交换后岂不是会有一个大于关键数据的数据在第一个位置？    
> 经过后来的详细思考，这种情况是不存在的，理由如下：   
> 由于是从后往前的下标end先开始移动，因此当他碰到比关键数据大的数据时会认定为正常数据不处理，因此继续往前走，一直到两种情况才会停下来  
> 1 遇到比关键数据小的的数据，此时beg再开始走动最后两个下标重合，那么这个比关键数据小的数据与关键数据交换位置，仍然是排列成功的。   
> 2 遇到了光标beg，由于beg位置的数据一定是比关键数据要小的，因此这时候beg的数据与关键数据交换位置也是没有问题的。   
> 3 任何情况都不会有两个光标在一个比关键数据大的地方停下来并交换。    

3 将数组分为两段，关键数据前的数组与关键数据后的数组，各自再进行递归，来重复1和2的过程，直到数组中的所有数据都进行排序。   
### 范例代码  
```c
#include <iostream>   
using namespace std;   
 
void Qsort(int a[], int low, int high)   
{   
    if(low >= high)	//如果low大于等于high该段数据为空或者只有一个数据没有必要排序   
    {  
        return;   
    }   
    int first = low;  
    int last = high;    
    int key = a[first];//用数组的第一个数据作为关键数据   
 
//这段循环的赋值比较魔性，在first和last的互相赋值中并没有涉及到关键数据。   
//当last找到第一个比key大的值以后变覆盖给a[first]即原本是key的值。然后当first找到比key小的再给当时的last，last再开始行动。   
//而key值在循环结束前并没有赋值给别人，当循环结束后找到最后最中间那个位置了再将key赋值进去。   
//这里的理念可以理解为“一个萝卜一个坑”。一共只有三个坑，那么先不管key所在的位置，先按大小随意交换位置进行排序，最后将key放最中间，那么所有的数字都在，key左边都是比key小的，key右边都是比key大的，就ok了。     
    while(first < last)   
    {   
        while(first < last && a[last] >= key)   
        {   
            --last;  
        }   
 
        a[first] = a[last];//将比key小的赋值给first的位置（第一次的话就是key的位置，key先不管，最后处理）      
  
        while(first < last && a[first] <= key)   
        {  
            ++first;   
        }  
         
        a[last] = a[first];//将比key大的赋值给last的位置            
    }   
    a[first] = key;//此时first与last重合，为最中间的一个数字，把关键数据赋值给他。  
 
    Qsort(a, low, first-1);  
    Qsort(a, first+1, high);   
}  
int main()   
{    
    int a[] = {57, 68, 59, 52, 72, 28, 96, 33, 24};   
 
    Qsort(a, 0, sizeof(a) / sizeof(a[0]) - 1);/*这里原文第三个参数要减1否则内存越界*/   
 
    for(int i = 0; i < sizeof(a) / sizeof(a[0]); i++)   
        cout << a[i] << "";   
     
    return 0;   
}     
```
### 快速排序算法的时间复杂度
由于快速排序算法使用了分治思想，因此当分治思想使用到极致即为快速排序的最优情况。也就是说如果排序了n个关键字，每次排序的关键数据都在数组的最当中，将数组一分为二，那么各自还需要T(n/2)的时间，并且以递归的方式继续划分下去。    
**因此在最优的情况下，快速排序的时间复杂度为O(nlogn)。（通常平均情况我们也认为是此值）**   
同理，最坏的情况下为：待排序的数组为已经排序好的正序或者逆序，每次划分只得到一个比上一次划分少一个记录的子序列，另一个为空（实际上另一个数组为一个数字，但是一个数字不排序会return，因此视为空，等同于无效）。此时需要执行n‐1次递归调用，且第i次划分需要经过n‐i次关键字的比较才能找到第i个记录，也就是关键字的位置。   
**在最坏的情况下，快速排序会退化成冒泡排序，其的时间复杂度为O(n*n）。**     
### 快速排序算法的空间复杂度
就空间复杂度来说，主要是递归造成的栈空间的使用。   
最好情况，递归树的深度为log2n，其空间复杂度也就为O(logn)。   
最坏情况，需要进行n‐1递归调用，其空间复杂度为O(n)。    
平均情况，空间复杂度也为O(logn)。    
### 优化/变种
用来避免最差情况发生的方法：  
> 主元素的选取随机化：这样就会导致“每次分解一直找到的是最小元素和最大元素作为主元素”的概率很小，但还是可能发生。   

够避免其不会发生的方法：   
> 求序列的中值，然后选取序列的中值作为主元素。如果该值在数组中没有，则以离中值最近的那个数即可。      

