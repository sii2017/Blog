## Morris Traversal
目前我们已经几种方法遍历二叉树。   
一种是通过递归，在树非常高的时候，效率较低，优点是非常好理解的。  
一种是通过栈或者队列，非递归的方式，效率略高，但是比较难理解，且其中后序遍历尤为麻烦。   
最后一种是颜色标记遍历算法，方便理解，但是相当于空间换时间。   
莫里斯方法遍历二叉树，非递归，且可以在空间复杂度为O(1)的情况下完成遍历。   
> 值得注意的是，在leetcode中序遍历的题目中，我试了不同的算法进行遍历。递归法需要8ms，循环和颜色标记法需要4ms，而莫里斯遍历仅需要0ms，尽管莫里斯遍历会遍历右子树两次，但是由于不用操作多余的空间，仅需要移动，所以速度是最快的。   
   
### 中序遍历
先以中序遍历作为例子。   
中序遍历的顺序为，先访问左节点，再访问当前节点，最后访问右节点。而如果不使用递归，我们通常会遇到一个问题，当我们移动到了右节点，如何返回中节点进行接下去的遍历。   
通常我们会使用stack来存储之前的中节点，但是这会消耗不少空间。而莫里斯方法主要是“废物利用”了树中的null节点，与之前的某个父节点相连，因此当我们访问到那个节点后，就可以返回父节点，解决了遍历的时候无法返回的问题。   
步骤如下：  
1 如果当前节点的左孩子为空，则输出当前节点，并将其右孩子作为当前节点。  
2 如果当前节点的左孩子不为空，在当前节点的左子树中，找到它的最右节点，我们称之为前驱节点（我也不知道为什么叫这个   
2.1 如果前驱节点的右孩子为空，将它的右孩子设置为当前节点（那么之后遍历到它这个最后节点的时候可以返回现在的位置）。当前节点更新为当前节点的左孩子。    
2.2 如果前驱节点的右孩子为当前节点（说明刚从那里回来，已经遍历过左子树一次了），将它的右孩子重新设为空（恢复树的形状）。输出当前节点。当前节点更新为当前节点的右孩子。    
3 重复以上1、2直到当前节点为空。   
#### 代码
```c
void Morris(TreeNode* root)
{
	TreeNode* cur = root;

	while (cur)
	{
		if (!cur->left)	//如果左子树为空，则直接进到右子树继续遍历
		{
			cout << cur->val << endl;
			cur = cur->right;
		}
		else  //如果左子树不为空
		{
			TreeNode* node = cur->left;
			while (node->right && node->right != cur)	//找到该子树下最后节点（也是最右节点）   
			{
				if (node->right && node->right != cur)
					node = node->right;
			}
			if (!node->right)	//如果该最后节点的右节点为空说明尚未被遍历过，连接上当前节点cur，方便之后传送
			{
				node->right = cur;
				cur = cur->left;
			}
			else if (node->right == cur)	//如果该节点和当前节点相同，说明刚从那里传送回来，将起变回null，然后跑路右节点继续便利
			{
				cout << cur->val << endl;
				node->right = NULL;
				cur = cur->right;
			}
		}
	}
}
```
### 前序遍历
前序遍历则需要微调一下代码内容。   
由于前序遍历的规则是，先输出当前节点，再输出左节点，再输出右节点。与之前的中序遍历的顺序有所不同，所以我们要调整输出方面的规则。   
步骤如下：  
1 如果当前节点的左孩子为空，则输出当前节点，并将其右孩子作为当前节点。  
2 如果当前节点的左孩子不为空，在当前节点的左子树中，找到它的最右节点，我将其称之为可传送节点。        
2.1 如果可传送节点的右孩子为空，**说明是第一次访问这里，因此我们输出当前的节点值**，然后将它的右孩子设置为当前节点（那么之后遍历到它这个最后节点的时候可以返回现在的位置）。当前节点更新为当前节点的左孩子。    
2.2 如果前驱节点的右孩子为当前节点，**说明刚从那里回来，已经遍历过左子树一次了，因此我们并不再输出当前节点了**，然后将它的右孩子重新设为空（恢复树的形状）。当前节点更新为当前节点的右孩子。    
3 重复以上1、2直到当前节点为空。   
以上加粗字体，即是与中序遍历的区别。   
#### 代码
```c
void Morris(TreeNode* root)
{
	TreeNode* cur = root;

	while (cur)
	{
		if (!cur->left)	//如果左子树为空，则直接进到右子树继续遍历
		{
			cout << cur->val << endl;	
			cur = cur->right;
		}
		else  //如果左子树不为空
		{
			TreeNode* node = cur->left;
			while (node->right && node->right != cur)	//找到该子树下最后节点
			{
				if (node->right && node->right != cur)
					node = node->right;
			}
			if (!node->right)	//如果该最后节点的右节点为空说明尚未被遍历过，连接上当前节点cur，方便之后传送
			{
				cout << cur->val << endl;
				node->right = cur;
				cur = cur->left;
			}
			else if (node->right == cur)	//如果该节点和当前节点相同，说明刚从那里传送回来，将起变回null，然后跑路右节点继续便利
			{
				node->right = NULL;
				cur = cur->right;
			}
		}
	}
}
```