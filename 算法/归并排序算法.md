## 归并排序算法
归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。  
首先将已有序列进行分割，直到每隔序列只剩一个元素；然后将已有序的子序列依次排序并合并，最后得到完全有序的序列。   
![](https://github.com/sii2017/image/blob/master/MergeSort.jpg)
### 例子1
通过递归方式的归并排序。    
```c
#include <iostream>   
using namespace std;   

void MergeSort(int* num, int beg, int end)   
{  
	int mid;   
	if (beg >= end)	//如果数组只有一个数字则不再分割  
		return;   

	//先将数组进行分治分割  
	mid = (beg + end) / 2;   
	MergeSort(num, beg, mid);  
	MergeSort(num, mid + 1, end);  

	//再将数组进行排序及合并   
	int i = beg, j = mid + 1;	//i和j分别为前后两个数组的起始下标   
	int size = end - beg + 1;	//size用来申请内存  
	int k = 0;	//临时数组temp的下标   
	int* temp = (int*)malloc(size * sizeof(int));  
	
	while (i <= mid && j <= end)   
	{   
		//进行比较将小的数值赋值给temp数组，当一个数组到尽头后退出循环   
		if (num[i] < num[j])	  
		{  
			temp[k] = num[i];   
			i++;  
		}  
		else  
		{  
			temp[k] = num[j];  
			j++;  
		}  
		k++;  
	}  

	//把剩下的数组的值赋值给temp数组，由于剩下的一定是更大的，且排序的，所以按顺序赋值即可  
	while (i <= mid)  
	{  
		temp[k] = num[i];  
		k++;  
		i++;  
	}  
	while (j <= end)   
	{  
		temp[k] = num[j];  
		k++;  
		j++;  
	}   

	//按顺序将临时数组的数字赋值到num的相应位置  
	for (int l = 0; l < size; l++)  
	{  
		num[beg + l] = temp[l];   
	}  

	free(temp);  
	temp = NULL;  
	return;  
}   

int main()  
{   
	int tobesort[14] ={ 23,1,3,45,5,7,8,9,2,12,54,2,-1,24 };  
	MergeSort(tobesort, 0, 13);  

	for (int i = 0; i < 13; i++)  
		cout << tobesort[i] << " ";   
	cout << endl;  

	getchar();  
	return 0;   
}   
```   
### 例子2
通过迭代方式的归并排序。