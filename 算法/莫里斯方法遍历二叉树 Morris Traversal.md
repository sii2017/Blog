## Morris Traversal
目前我们已经几种方法遍历二叉树。   
一种是通过递归，在树非常高的时候，效率较低，优点是非常好理解的。  
一种是通过栈或者队列，非递归的方式，效率略高，但是比较难理解，且其中后序遍历尤为麻烦。   
最后一种是颜色标记遍历算法，方便理解，但是相当于空间换时间。   
莫里斯方法遍历二叉树，非递归，且可以在空间复杂度为O(1)的情况下完成遍历。   
### 前序遍历
以前序遍历作为例子。   
做一下简单的介绍，莫里斯方法主要是废物利用了树中的null节点，与之前的某个父节点相连，因此当我们访问到那个节点后，就可以返回父节点，解决了遍历的时候无法返回的问题。   
步骤如下：  
1 如果当前节点的左孩子为空，则输出当前节点，并将其右孩子作为当前节点。  
2 如果当前节点的左孩子不为空，在当前节点的左子树中，找到在中序遍历中的最后一个节点，通常为最右节点，也可能是最右节点的左节点，我们称之为前驱节点（我也不知道为什么叫这个   
2.1 如果前驱节点的右孩子为空，将它的右孩子设置为当前节点（那么之后遍历到它这个最后节点的时候可以返回现在的位置）。当前节点更新为当前节点的左孩子。    
2.2 如果前驱节点的右孩子为当前节点（说明刚从那里回来，已经遍历过左子树一次了），将它的右孩子重新设为空（恢复树的形状）。输出当前节点。当前节点更新为当前节点的右孩子。    
3 重复以上1、2直到当前节点为空。   
#### 代码
```c
void Morris(TreeNode* root)
{
	TreeNode* cur = root;

	while (cur)
	{
		if (!cur->left)	//如果左子树为空，则直接进到右子树继续遍历
		{
			cout << cur->val << endl;
			cur = cur->right;
		}
		else  //如果左子树不为空
		{
			TreeNode* node = cur->left;
			while ((node->left || node->right) && node->left != cur && node->right != cur)	//找到该子树下最后节点
			{
				if (node->right && node->right != cur)
					node = node->right;
				else if (node->left && node->left != cur)
					node = node->left;
			}
			if (!node->right)	//如果该最后节点的右节点为空说明尚未被遍历过，连接上当前节点cur，方便之后传送
			{
				node->right = cur;
				cur = cur->left;
			}
			else if (node->right == cur)	//如果该节点和当前节点相同，说明刚从那里传送回来，将起变回null，然后跑路右节点继续便利
			{
				cout << cur->val << endl;
				node->right = NULL;
				cur = cur->right;
			}
		}
	}
}
```