# 排序算法汇总
待排序的记录序列中可能存在两个或两个以上关键字相等的记录。排序前的序列中Ri领先于Rj（即i<j）。若在排序后的序列中Ri仍然领先于Rj，则称所用的方法是稳定的。   
也就是说稳定排序算法不会全面/完全改变待排序元素的位置，只会改变部分元素的位置。而不稳定排序则可能会全盘改变元素的位置。   
## 稳定排序
**稳定排序算法有插入排序，基数排序，归并排序，冒泡排序，计数排序等。**   
### 冒泡排序
时间复杂度：最好的情况，表本身就是有序的，n-1次比较，时间复杂度为O(n)；最坏的情况，表是逆序的，因此需要比较1+2+3+...(n-1)=(n(n-1))/2，时间复杂度为O(n2)。   
优点：简单稳定。   
缺点：慢，每次只能移动相邻两个数据，效率低。   
相关实现参考同目录下《冒泡排序算法》。   
### 归并排序
时间复杂度：O(nlogn)   
优点：效率高，稳定。   
缺点：占用内存较多   
相关实现参考同目录下《归并排序算法》。  
### 插入排序 
时间复杂度：最好情况本身就是有序的，比较次数为n-1次，没有移动记录时间复杂度为O(n)；最坏情况则是待排序队列为逆序，因此比较次数为2+3+4+...+n=(n+2)(n-1)/2，时间复杂度为O(n2)。   
优点：比选择排序和冒泡排序的性能要好一些。  
缺点：效率仍旧较低。   
相关实现参考同目录下《插入排序算法》 
## 不稳定排序 
**不稳定排序算法有快速排序，希尔排序，简单选择排序，堆排序等。**   
### 快速排序
时间复杂度：通常情况下会采用分支思想，时间复杂度为O(nlogn)。在最坏的情况下，当需要排序的数组为正序或逆序，每次划分只能得到一个比上一次划分少一个元素的子集，这种情况下会退化成冒泡排序，时间复杂度为O(n2)。   
优点：这是目前来说最快的排序算法。   
缺点：不稳定。  
相关实现参考同目录下《快速排序算法》。    