## 摩尔投票算法
摩尔投票算法可以用来解答“求众数”相关的算法题。  
> 众数：是指在数组中出现次数大于n/2的元素。（n为数组中元素的数量）    
### 求众数
给定一个大小为n的数组，找到其中的众数。  
可以假设数组是非空的，并且给定的数组总是存在众数。   
通常我们的常规思路有两种：   
1 排序整个数组，然后计算每一种元素的出现次数，大于2/n则是众数。空间复杂度是O(1)，但是由于需要排序，时间复杂度就比较高。  
2 由于上一种方式的时间复杂度高，可以使用map来解答。使用map的话空间复杂度会上升，但是时间复杂度是线性的。具体的做法就是将每个元素及其出现从次数存入map，最后返回符合要求的就可以了。   
但是摩尔投票算法在解答这道题的时候，空间复杂度和时间复杂度都更为优秀。   
### 摩尔投票算法详解
在求众数题目的设定中，必然存在一个众数，他的出现次数大于整个数组数量的一半。  
这个解法类似于消消乐，我们每次用两个不同的数字进行消除，由于众数的出现次数总是大于整个数组数量的一半的，那么经过一轮消除后，总会剩下来至少一个元素。而这个元素，就是众数。   
显然由于它数量众多，在一对一的消除中，存活了下来。   
### 代码
```c
int majorityElement(vector<int>& nums)   
{  
	int latest = nums.front();   
	int count = 1;   
	for (auto itr = nums.begin() + 1; itr != nums.end(); itr++)   
	{  
		//如果count当前为0，即前一对已经消除完了，那么我们重新分配最新的latest以及给count+1   
		if (!count)   
		{   
			latest = *itr;  
			count++;  
		}  
		else   
		{  
			if (latest == *itr)   //如果遇到两个相等的数字，则直接往上加    
				count++;  
			else  	//如果遇到不等的数字，直接减一   
				count--;  
		}   
	}   
	return latest;  
}   
```