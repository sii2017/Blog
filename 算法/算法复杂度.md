# 算法复杂度 
计算机在完成运算处理的过程中需要根据输入数据的大小和算法效率来消耗一定的处理器资源。要想编写出能高效运行的程序，我们就需要考虑到算法的效率。   
算法的效率主要由以下两个复杂度来评估：    
**时间复杂度**：评估执行程序所需的时间。可以估算出程序对处理器的使用程度。   
**空间复杂度**：评估执行程序所需的存储空间。可以估算出程序对计算机内存的使用程度。   
设计算法时，一般是要先考虑系统环境，然后权衡时间复杂度和空间复杂度，选取一个平衡点。不过，时间复杂度要比空间复杂度更容易产生问题，因此算法研究的主要也是时间复杂度，不特别说明的情况下，**算法复杂度就是指时间复杂度。**   
## 时间复杂度  
### 时间频度 
一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道，且不同的运行环境也不同。且我们不可能也不需要对每个算法都进行测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。  
一个算法花费的时间与算法中语句的**执行次数**成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。  
### 时间复杂度 
时间频度T(n)中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律，为此我们引入时间复杂度的概念。   
一般情况下，算法中基本操作重复执行的是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T（n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数，记作T(n)=O(f(n))，它称为算法的渐进时间复杂度，简称时间复杂度。    
### 大O表示法
用O( )来体现算法时间复杂度的记法，我们称之为大O表示法。   
算法复杂度可以从最理想情况、平均情况和最坏情况三个角度来评估，由于平均情况大多和最坏情况持平，而且评估最坏情况也可以避免后顾之忧，因此一般情况下，我们设计算法时都要直接估算最坏情况的复杂度（即极限的情况下）。      
O(f(n)）中的f(n)的值可以为1、n、logn、n²等，因此**我们可以将O(1)、O(n)、O(logn)、O(n²)分别可以称为常数阶、线性阶、对数阶和平方阶**，那么如何推导出f(n)的值呢？我们接着来看推导大O阶的方法。  
### 推导大O阶
按照以下三个规则：  
1 用常数1来取代运行时间中所有加法常数。     
2 修改后的运行次数函数中，只保留最高阶项。   
3 如果最高阶项存在且不是1，则去除与这个项相乘的常数。   
#### 常数阶
```c
int sum= 0, n= 100;//执行一次   
sum= (1+n)*n/2;//执行一次   
cout << sum << endl;//执行一次  
```   
以上算法每行代码各执行一次，总执行次数为3，即f(n)=3，根据推导规则1，用常数1代替所有的加法常数，因此时间复杂度为O(1)。   
#### 线性阶  
线性阶主要分析循环结构的运行情况   
```c
for(int i=0; i<n; i++)   
{   
	//时间复杂度为O(1)的算法   
}    
```    
以上代码将复杂度为O(1)的算法重复执行n次，因此时间复杂度为O(n)。   
#### 对数阶   
```c   
int num= 1;   
while(num < n)   
{   
	num= num*2;   
	//时间复杂度为O(1)的算法  
}   
```   
可以看出上面的代码，随着number每次乘以2后，都会越来越接近n，当number不小于n时就会退出循环。假设循环的次数为X，则由2^x=n得出x=log₂n，因此得出这个算法的时间复杂度为O(logn)。   
#### 平方阶
```c
for(int i= 0; i<n; i++)   
{   
	for(int j=0; j<n; j++)   
	{   
		//复杂度为O(1)的算法   
	}   
}   
```   
显然，内存的n次循环的时间复杂度为线性阶O(n)，再经过外层的n次循环，则整个嵌套循环的时间复杂度为O(n²)。   
#### 其他常见复杂度
除了常数阶、线性阶、平方阶、对数阶，还有如下时间复杂度：   
f(n)=nlogn时，时间复杂度为O(nlogn)，可以称为nlogn阶。   
f(n)=n³时，时间复杂度为O(n³)，可以称为立方阶。    
f(n)=2ⁿ时，时间复杂度为O(2ⁿ)，可以称为指数阶。   
f(n)=n!时，时间复杂度为O(n!)，可以称为阶乘阶。    
f(n)=(√n时，时间复杂度为O(√n)，可以称为平方根阶。    
### 复杂度的比较
![](https://github.com/sii2017/image/blob/master/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E6%AF%94%E8%BE%83.png)   
从上表可以看出，O(n)、O(logn)、O(√n )、O(nlogn )随着n的增加，复杂度提升不大，因此这些复杂度属于效率高的算法，反观O(2ⁿ)和O(n!)当n增加到50时，复杂度就突破十位数了，这种效率极差的复杂度最好不要出现在程序中，因此在动手编程时要评估所写算法的最坏情况的复杂度。   
常用的时间复杂度按照耗费的时间从小到大依次是：    
**O(1)<O(logn)<O(n)<O(nlogn)<O(n²)<O(n³)<O(2ⁿ)<O(n!)**   
## 空间复杂度
算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作: S(n)= O(f(n)),其中，n为问题的规模， f(n)为语句关于 n 所占存储空间的函数。    
一般情况下， 一个程序在机器上执行时，除了需要存储程序本身的指令、常数、变量和输入数据外，还需要存储对数据操作的存储单元，若输入数据所占空间只取决于问题本身，和算法无关，这样只需要分析该算法在实现时所需的辅助单元即可。若算法执行时所需的辅助空间相对于输入数据量而言是个常数，则称此算法为原地工作，空间复杂度为 O(1) 。     
通常，我们都使用"时间复杂度"来指运行时间的需求，使用"空间复杂度"指空间需求。当不用限定词地使用"复杂度'时，通常都是指时间复杂度。显然我们这本书重点要讲的还是算法的时间复杂度的问题。     