## 二叉树的遍历
### 前序遍历
前序遍历首先访问根结点然后遍历左子树，最后遍历右子树。   
在遍历左、右子树时，仍然先访问根结点，然后遍历左子树，最后遍历右子树。   
```c
//通过递归的前序遍历     
void PreOrder(TreeNode* root)     
{  
	if (root != NULL)  
	{   
		cout << root->c;  
		PreOrder(root->left);  
		PreOrder(root->right);   
	}   
}    

//非递归的前序遍历  
void PreOrderByCircle(TreeNode* root)   
{   
	stack<TreeNode*> st;  
	TreeNode* p = root;  

	while (p || !st.empty())  
	{  
		if (p)  
		{  
			cout << p->c;   
			st.push(p);  
			p = p->left;  
		}   
		else   
		{  
			p = st.top()->right;  
			st.pop();  
		}  
	}  
}  
```
### 中序遍历
中序遍历首先遍历左子树，然后访问根结点，最后遍历右子树。
```c
//递归，中序遍历   
void InOrder(TreeNode* root)  
{  
	if (root != NULL)  
	{  
		InOrder(root->left);   
		cout << root->c;   
		InOrder(root->right);   
	}  
}   

//非递归，中序遍历   
void InOrderByCircle(TreeNode* root)  
{  
	TreeNode* p;  
	p = root;  
	stack<TreeNode*> st;  

	while (p || !st.empty())   
	{   
		if (p)  
		{  
			st.push(p);  
			p = p->left;   
		}  
		else   
		{  
			cout << st.top()->c;   
			p = st.top()->right;  
			st.pop();  
		}  
	}  
}  
```
### 后序遍历
后序遍历是先遍历左子树，再遍历右子树，最后访问根节点。   
```c
//递归，后序遍历  
void PostOrder(TreeNode* root)    
{   
	if (root->left)  
		PostOrder(root->left);  
	if (root->right)   
		PostOrder(root->right);  
	cout << root->c;  
}  
```
非递归的后序遍历可行，不过比较麻烦，需要在TreeNode结构中增加一个bool值，表示该节点是否被访问过。   
### 层序遍历
层序遍历按顺序遍历每一层，同时每一层的遍历顺序从左到右。   
层序遍历需要借助标准库容器模板的queue。    
```c
void LevelOrder(TreeNode* root)  
{  
	if (!root)  
		return;  
  
	queue<TreeNode*> qt;  
	qt.push(root);  
	while (!qt.empty())  
	{  
		if (qt.front() == NULL)  
		{  
			qt.pop();  
			continue;  
		}   
		cout << qt.front()->c << endl;   
		qt.push(qt.front()->left);   
		qt.push(qt.front()->right);   
		qt.pop();  
	}    
}    
```   
### 颜色标记遍历算法
上面的遍历方式，迭代遍历法易于理解，循环遍历法效率高，但是前中后序遍历的方式却截然不同，让人难以记忆。   
在题解中，看到一种颜色标记遍历算法，可以将前中后序统一起来。值得记录。   
1 使用pair为每个压入栈的节点设置颜色。   
2 已经访问过的节点标灰色，没有访问过的节点标白色。（其实可以优化成bool值）   
3 第一个压入的根节点首次标记为白色。   
4 然后按照逆序的顺序压入栈。比如如果要左中右，就以右中左的顺序压入。   
以中序遍历做例子：   
```c
vector<int> inorderTraversal(TreeNode* root)
{
	vector<int> ans;

	int white = 0;
	int gray = 1;
	stack<pair<int, TreeNode*>>s;
	s.push(pair<int, TreeNode*>{ white, root });
	while (!s.empty())
	{
		int color = s.top().first;
		TreeNode* t = s.top().second;
		s.pop();

		if (t == NULL)
			continue;

		if (color == white)
		{
			s.push(pair<int, TreeNode*>(white, t->right));
			s.push(pair<int, TreeNode*>(gray, t));
			s.push(pair<int, TreeNode*>(white, t->left));
		}
		else ans.push_back(t->val);
	}
	return ans;
}
```
