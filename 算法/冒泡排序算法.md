## 冒泡排序算法
冒泡排序是很基本的一种算法。   
冒泡排序是一种**稳定**排序。    
冒泡排序：从开始到结尾比较相邻元素，将较大的元素右移直到最后。那么最后一个元素必定是最大的。下次再循环比较相邻元素，将较大的元素右移到倒数第二。以此类推，一直到后面的元素均排序完成。    
5 4 3 2 1   
将5和4比较，将5和4交换位置。4 5 3 2 1   
将5和3比较，将5和3交换位置。4 3 5 2 1  
将5和2比较，以此类推。   
完成第一次循环后，数列为4 3 2 1 5   
下一次循环仍然从第一个元素开始，但是到倒数第二个元素结束，不用去排列最后一个元素，它已经是最大了。   
第三次循环仍然从第一个元素开始，到倒数第三个元素结束，不用去排列倒数两个元素，他们已经是正序排列且最大的了。  
### 例子
```c
void BubbleSort(int* num, int size)  
{   
	if (num == NULL)  
	{   
		cout << "num is empty" << endl;  
		return;   
	}  

	int tsize = size;   //获取总长度，第一次排序将会遍历整个数组   
	bool sorted = false;  //如果某一次遍历没有交换过位置，意为着已经排序完成，不用再进行多余的遍历了   
	while (!sorted && tsize>1)   //如果排序完成或者剩下没排序的元素只有1个了，就说明完成排序了   
	{  
		sorted = true;   //每次遍历开头默认已经排序完成  
		for (int i = 0; i < tsize-1; i++)   
		{   
			if (num[i] > num[i + 1])  
			{   
				int temp = num[i];   
				num[i] = num[i + 1];  
				num[i + 1] = temp;   
				sorted = false;  //但凡交换过位置说明还没有排列完成，给出false继续循环。   
			}  
		}   
		tsize--;  //每次排序完最后一个元素都是最大的了，不用再排序了，下次循环就不用遍历从后往前已经排序好的元素了。   
	}   
	return;  
}    
```   
### 时间复杂度
最优情况下，数组已经是正序的，那么排序一次就能退出循环，因此最优的时间复杂度为O(n)。   
最差的情况下是，数组是逆序的，要完成n-1此排序才能退出循环。因此最差的时间复杂度为O(n2)。   
冒泡排序与其他的一些排序来说，效率并不高，但是冒泡排序是一种**稳定的排序算法**。   