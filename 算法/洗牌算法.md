## 洗牌算法
洗牌算法是很经典的一款“随机”算法。   
先来思考一个问题：    
> 有一个大小为 100 的数组，里面的元素是从 1 到 100 按顺序排列，怎样随机的从里面选择 1 个数？   
   
最简单的方法是利用随机数函数，这样就可以拿到一个 0 到 99 的随机数，然后去数组找对应的位置就即可。    
接下来在思考一个问题：    
> 有一个大小为100的数组，里面的元素是从 1 到 100 按顺序排列，怎样随机的从里面选择 50 个数？    
（注意：数字不能重复）     
  
如果按照第一种方法，那么会有重复的数字的。   
换个思路，如果我们把数组随机打乱，那么选取其中前五十个数字，或者是随机的某段50个数字，就可以了。   
> 进阶问题，如何打乱随机数呢？   
   
打个比方：一副扑克有 54 张牌，有 54! 种排列方式。所谓的打乱指的是，你所执行的操作，应该能够**等概率**地生成 这 54! 种结果中的一种。    
如果不考虑时间，那么有一种很暴力的方法，就是生成所有54!个排列，然后随机抽一个。   
但是这种时间复杂度是难以被接受的，需要O(n!)的时间！   
这时候，洗牌算法可以高效的做到这一点。   
### 洗牌算法详解
Fisher–Yates shuffle 算法由 Ronald Fisher 和 Frank Yates 于 1938 年提出，在 1964 年由 Richard Durstenfeld 改编为适用于电脑编程的版本。    
这个算法很牛逼却很好理解，通俗的解释就是：将最后一个数和前面任意 n-1 个数中的一个数进行交换，然后倒数第二个数和前面任意 n-2 个数中的一个数进行交换。        
### 代码
```c
void Fisher_Yates(vector<int>& vec)
{
	int size = vec.size();
	if (size < 2)
		return;

	default_random_engine e;	//随机数引擎类
	//e.seed(time(NULL));		//喂种子失败
	e.seed(clock());		//喂种子，注意这里不能用time()，因为time只精确到秒，如果运行的快则无法真正随机，而clock精确到毫秒

	for (int i = size - 1; i > 1; i--)
	{
		uniform_int_distribution<unsigned> u(0, i - 1);
		swap(vec[i], vec[u(e)]);
	}
}
```   