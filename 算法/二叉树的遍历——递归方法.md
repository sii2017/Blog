## 二叉树的遍历——递归方法
递归是二叉树普遍的遍历方式，对于初学者来说也很容易理解。   
### 前序遍历
前序遍历首先访问根结点然后遍历左子树，最后遍历右子树。   
在遍历左、右子树时，仍然先访问根结点，然后遍历左子树，最后遍历右子树。   
```c
//通过递归的前序遍历     
void PreOrder(TreeNode* root)     
{  
	if (root != NULL)  
	{   
		cout << root->c;  
		PreOrder(root->left);  
		PreOrder(root->right);   
	}   
}    
```
### 中序遍历
中序遍历首先遍历左子树，然后访问根结点，最后遍历右子树。
```c
//递归，中序遍历   
void InOrder(TreeNode* root)  
{  
	if (root != NULL)  
	{  
		InOrder(root->left);   
		cout << root->c;   
		InOrder(root->right);   
	}  
}   


```
### 后序遍历
后序遍历是先遍历左子树，再遍历右子树，最后访问根节点。   
```c
//递归，后序遍历  
void PostOrder(TreeNode* root)    
{   
	if (root->left)  
		PostOrder(root->left);  
	if (root->right)   
		PostOrder(root->right);  
	cout << root->c;  
}  
```
非递归的后序遍历可行，不过比较麻烦，需要在TreeNode结构中增加一个bool值，表示该节点是否被访问过。   
### 层序遍历  
目前层序遍历不支持递归的方式。   
### 颜色标记遍历算法
上面的遍历方式，迭代遍历法易于理解，循环遍历法效率高，但是前中后序遍历的方式却截然不同，让人难以记忆。   
在题解中，看到一种颜色标记遍历算法，可以将前中后序统一起来。值得记录。   
1 使用pair为每个压入栈的节点设置颜色。   
2 已经访问过的节点标灰色，没有访问过的节点标白色。（其实可以优化成bool值）   
3 第一个压入的根节点首次标记为白色。   
4 然后按照逆序的顺序压入栈。比如如果要左中右，就以右中左的顺序压入。   
以中序遍历做例子：   
```c
vector<int> inorderTraversal(TreeNode* root)
{
	vector<int> ans;

	int white = 0;
	int gray = 1;
	stack<pair<int, TreeNode*>>s;
	s.push(pair<int, TreeNode*>{ white, root });
	while (!s.empty())
	{
		int color = s.top().first;
		TreeNode* t = s.top().second;
		s.pop();

		if (t == NULL)
			continue;

		if (color == white)
		{
			s.push(pair<int, TreeNode*>(white, t->right));
			s.push(pair<int, TreeNode*>(gray, t));
			s.push(pair<int, TreeNode*>(white, t->left));
		}
		else ans.push_back(t->val);
	}
	return ans;
}
```
