# 动态规划算法
## 爬楼梯
这里借用leetcode的一道基础的动态规划的题目来做例子。   
> 70.爬楼梯   
> 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。   
> 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？   

> 注意：给定 n 是一个正整数。   

> 示例 1：    
> 输入： 共2阶楼梯      
> 输出： 有两种方法可以爬到楼顶。        
> 解释：     
> 1.  1 阶 + 1 阶   
> 2.  2 阶   
  
> 示例 2：    
> 输入： 共3阶楼梯       
> 输出： 有三种方法可以爬到楼顶。      
> 解释：      
> 1.  1 阶 + 1 阶 + 1 阶  
> 2.  1 阶 + 2 阶  
> 3.  2 阶 + 1 阶   
### 模型
思路如下：   
1 打个比方我们要计算10阶台阶的情况下，有多少种方式。   
2 从最后开始看，我们走到第10阶台阶有几种方式？   
答：两种，一种是从9阶走到10，一种是从8阶走到10。   
3 那么我们假设dp[n]代表走到n阶阶梯的方式数量。dp[10]=dp[9]+dp[8]。是的，我们走到10阶只有两种方式，一种是从9到10，一种是从8到10。   
4 以此类推，我们再往前推，到走到台阶9有几种方式？走到台阶8有几种方式？  
答：各为两种。走到台阶9分别是从台阶7走和台阶8走。dp[9]=dp[8]+dp[7]。走到台阶8分别是从台阶7走和台阶6走。dp[8]=dp[7]+dp[6]。   
5 我们可以推导出一个公式：dp[n]=dp[n-1]+dp[n-2]。   
6 显然台阶数为0的时候，方法为0。台阶数为1的时候方法为1。台阶数为2的时候方法为2。我们可以写代码了。   
### 代码
```c
class Solution   
{  
public:   
	int climbStairs(int n)  
	{  
		if (n < 1)   //如果台阶小于1，即为0，方式也为0   
			return 0;   
		else if (n == 1)  //如果台阶等于1，那么只有一种方式  
			return 1;   
		else if (n == 2)   //如果台阶等于2，那么只有2种方式   
			return 2;   
		//其余的通过递归来进行运算  
		return climbStairs(n - 1) + climbStairs(n - 2);   
	}   
};   
```   
但是这个代码有一个问题：效率。    
![](https://github.com/sii2017/image/blob/master/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%921.jpg)   
可以看到我们需要的方法是一颗二叉树，而节点的数量就是我们需要计算的次数，为2的n平方。   
![](https://github.com/sii2017/image/blob/master/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922.jpg)   
由于其中有不少重复的计算，因此我们可以将计算过的数值放入map或者数组中，直接使用可以节省相当多的算力。  
### 代码优化版
```c
class Solution {   
public:   
    int climbStairs(int n) {   
        if (dp.size() < n)   
			dp.insert(dp.begin(), n+1, -1);   //扩容dp，并且全部置于-1   

		if (n < 1)    
			return 0;   
		else if (n == 1)  
			return 1;   
		else if (n == 2)    
			return 2;   

		if (dp[n - 1] < 0)   
		{   
			dp[n - 1] = climbStairs(n - 1);   
		}   
		if (dp[n - 2] < 0)   
		{   
			dp[n - 2] = climbStairs(n - 2);   
		}   
		dp[n] = dp[n - 1] + dp[n - 2];   
		return dp[n];   
    }   
private:  
    vector<int> dp;   
};    
```   
由于每一步计算后都会被保存下来，保证每一步只有一次计算，因此时间复杂度就变成了n。  
### 代码优化终极版
上一个版本的代码已经比较优秀了，第一个版本的代码在运行n=30时花费时间6秒，而上一个版本的代码只花费了1秒不到。   
而这个终极版再次优化，体现在两点：
1 使用迭代替代递归，进一步优化空间效率和时间效率。   
2 不再需要通过vector或者map来记录，进一步优化空间效率。   
**具体思路如下：**   
在之前的概念中，我们已经知道，走到第十阶的数量是由走到第八阶和走到第九阶两个数量加起来决定的，并且可以以此往下推。   
那么我们是不是能从前往后推呢？   
我们可以确定的是：走到第一阶只有一种方法， 走到第二阶只有两种方法。因此我们知道，走到第三阶的方法是1+2=3。那我们以此类推不就知道往后的数字了吗?   
![](https://github.com/sii2017/image/blob/master/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%923.jpg)   
```c
class Solution {   
public:  
	int climbStairs(int n)    
	{   
		if (n < 1)  
			return 0;  
		if (n == 1)  
			return 1;  
		if (n == 2)   
			return 2;  

		int a = 1;   //替代n-2，并且在迭代中更新数值  
		int b = 2;   //替代n-1，并且在迭代中更新数值   
		int temp;   //替代n的方法总是，等于a+b，并且在迭代中更新数值  
		for (int i = 3; i < n + 1; i++)  
		{  
			temp = a + b;  
			a = b;  
			b = temp;   
		}  
		return temp;  //迭代结束后，temp就是最终的步数了  
	}   
};  
```     
时间复杂度为O(n），空间复杂度为O(1)。   
爬楼梯案例到这里就结束了。   