# 动态规划算法
以下从易到难的通过一些例题来介绍动态规划。   
**这是野路子。正规路子请看《算法导论》。**   
动态规划算法当中包含了三个重要的概念：  
**1 最优子结构。**  
**2 边界。**   
**3 状态转移公式。**   
理论知识我就不多说了，因为理论知识我自己也有点晕。通过例题以及这三个重要的概念来理解动态规划吧。   
## 爬楼梯
这里借用leetcode的一道最基础的动态规划的题目来做例子。   
> 70.爬楼梯   
> 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。   
> 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？   

> 注意：给定 n 是一个正整数。   

> 示例 1：    
> 输入： 共2阶楼梯      
> 输出： 有两种方法可以爬到楼顶。        
> 解释：     
> 1.  1 阶 + 1 阶   
> 2.  2 阶   
  
> 示例 2：    
> 输入： 共3阶楼梯       
> 输出： 有三种方法可以爬到楼顶。      
> 解释：      
> 1.  1 阶 + 1 阶 + 1 阶  
> 2.  1 阶 + 2 阶  
> 3.  2 阶 + 1 阶   
### 模型
思路如下：   
1 打个比方我们要计算10阶台阶的情况下，有多少种方式。   
2 从最后开始看，我们走到第10阶台阶有几种方式？   
答：两种，一种是从9阶走到10，一种是从8阶走到10。   
3 那么我们假设dp[n]代表走到n阶阶梯的方式数量。dp[10]=dp[9]+dp[8]。是的，我们走到10阶只有两种方式，一种是从9到10，一种是从8到10。   
> 在这里。dp[9]和dp[8]就是dp[10]的**最优子结构**。   
    
4 以此类推，我们再往前推，到走到台阶9有几种方式？走到台阶8有几种方式？  
答：各为两种。走到台阶9分别是从台阶7走和台阶8走。dp[9]=dp[8]+dp[7]。走到台阶8分别是从台阶7走和台阶6走。dp[8]=dp[7]+dp[6]。   
5 我们可以推导出一个公式：dp[n]=dp[n-1]+dp[n-2]。   
> 在这里，dp[n]=dp[n-1]+dp[n-2]就是前面所说的**状态转移公式**。     
    
6 显然台阶数为0的时候，方法为0。台阶数为1的时候方法为1。台阶数为2的时候方法为2。   
> 在这里，dp[1]和dp[2]是我们能直接得出结果的，也就是动态规划里的**边界**。   
   
以上，我们可以写代码了。   
### 代码
```c
class Solution   
{  
public:   
	int climbStairs(int n)  
	{  
		if (n < 1)   //如果台阶小于1，即为0，方式也为0   
			return 0;   
		else if (n == 1)  //如果台阶等于1，那么只有一种方式  
			return 1;   
		else if (n == 2)   //如果台阶等于2，那么只有2种方式   
			return 2;   
		//其余的通过递归来进行运算  
		return climbStairs(n - 1) + climbStairs(n - 2);   
	}   
};   
```   
但是这个代码有一个问题：效率。    
![](https://github.com/sii2017/image/blob/master/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%921.jpg)   
可以看到我们需要的方法是一颗二叉树，而节点的数量就是我们需要计算的次数，为2的n平方。   
![](https://github.com/sii2017/image/blob/master/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922.jpg)   
由于其中有不少重复的计算，因此我们可以将计算过的数值放入map或者数组中，直接使用可以节省相当多的算力。  
### 代码优化版
```c
class Solution {   
public:   
    int climbStairs(int n) {   
        if (dp.size() < n)   
			dp.insert(dp.begin(), n+1, -1);   //扩容dp，并且全部置于-1   

		if (n < 1)    
			return 0;   
		else if (n == 1)  
			return 1;   
		else if (n == 2)    
			return 2;   

		if (dp[n - 1] < 0)   
		{   
			dp[n - 1] = climbStairs(n - 1);   
		}   
		if (dp[n - 2] < 0)   
		{   
			dp[n - 2] = climbStairs(n - 2);   
		}   
		dp[n] = dp[n - 1] + dp[n - 2];   
		return dp[n];   
    }   
private:  
    vector<int> dp;   
};    
```   
由于每一步计算后都会被保存下来，保证每一步只有一次计算，因此时间复杂度就变成了n。  
### 代码优化终极版
上一个版本的代码已经比较优秀了，第一个版本的代码在运行n=30时花费时间6秒，而上一个版本的代码只花费了1秒不到。   
而这个终极版再次优化，体现在两点：
1 使用迭代替代递归，进一步优化空间效率和时间效率。   
2 不再需要通过vector或者map来记录，进一步优化空间效率。   
**具体思路如下：**   
在之前的概念中，我们已经知道，走到第十阶的数量是由走到第八阶和走到第九阶两个数量加起来决定的，并且可以以此往下推。   
那么我们是不是能从前往后推呢？   
我们可以确定的是：走到第一阶只有一种方法， 走到第二阶只有两种方法。因此我们知道，走到第三阶的方法是1+2=3。那我们以此类推不就知道往后的数字了吗?   
![](https://github.com/sii2017/image/blob/master/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%923.jpg)   
```c
class Solution {   
public:  
	int climbStairs(int n)    
	{   
		if (n < 1)  
			return 0;  
		if (n == 1)  
			return 1;  
		if (n == 2)   
			return 2;  

		int a = 1;   //替代n-2，并且在迭代中更新数值  
		int b = 2;   //替代n-1，并且在迭代中更新数值   
		int temp;   //替代n的方法总是，等于a+b，并且在迭代中更新数值  
		for (int i = 3; i < n + 1; i++)  
		{  
			temp = a + b;  
			a = b;  
			b = temp;   
		}  
		return temp;  //迭代结束后，temp就是最终的步数了  
	}   
};  
```     
时间复杂度为O(n），空间复杂度为O(1)。   
爬楼梯案例到这里就结束了。   
## 不同路径 
来源：leetcode   
这是继我完成上一道题后，独立完成的第二道题。其中“递归普通版”和“递归优化版”已经可以独立完成了，而“最终优化版”的模型还是参考了其它人的思路。   
题目如下：   
> 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。   
> 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。   
> 问总共有多少条不同的路径？    
   
![](https://github.com/sii2017/image/blob/master/leetcode62.png)   
> 示例 1:   
> 输入: m = 3, n = 2  
> 输出: 3   
> 解释:   
> 从左上角开始，总共有 3 条路径可以到达右下角。  
> 1. 向右 -> 向右 -> 向下   
> 2. 向右 -> 向下 -> 向右  
> 3. 向下 -> 向右 -> 向右   
  
> 示例 2:  
> 输入: m = 7, n = 3  
> 输出: 28   
### 递归低效版
这是最简单的建立模型的方式。   
与上一个案例一样，从最后开始考虑。达到(m,n)的路线数量是由什么决定的？   
由于题目规定，只能朝右或者朝下进行移动，达到(m,n)只有两种途径，一种是从(m-1,n)来，一种是从(m,n-1)来。   
因此达到(m,n)路线的数量就是“到达(m-1,n)路线的数量”加上“到达(m,n-1)路线的数量”的总和，并且以此往前类推。   
我们设F(m,n)为到达(m,n)的路线的数量。   
那么我们可以得出这么一个公式：F(m,n)= F(m-1,n)+F(m,n-1)。  
> F(m-1,n)和F(m,n-1)就是F(m,n)的**最优子结构**以及F(m,n)= F(m-1,n)+F(m,n-1)就是**状态转移公式**。    
    
有关于这个问题的边界是什么？  
那就是当m或者n为1的时候，也就是在地图上贴边了，这时候就不用再往前计算了。一方面1也无法再减1，另外一方面，贴边了就注定只有一条路线了，那就是从起点贴着边直接过来。   
> 因此，F(m,n)= 1 (如果m=1||n=1)；就是**边界**了。   
      
根据这个模型，我们可以写代码了。   
```c
class Solution  
{  
public:  
	int uniquePaths(int m, int n)   
	{  
		if (m == 1)  //如果m为1，说明已经贴最左边，只有一条路线了。   
			return 1;  
		if (n == 1)  //如果n为1，说明已经贴最右边，只有一条路线了。   
			return 1;   

		return uniquePaths(m - 1, n) + uniquePaths(m, n - 1);   //根据公式，通过递归将前面的两种路线的合加起来   
	}   
};   
```   
这个递归是最容易理解的，同时他也有着和上一题同样的问题，它会进行很多重复的计算，时间复杂度会达到指数级，因此，我们进入下一步的优化。   
### 递归优化版
递归的优化版还是很好理解的，由于会进行巨量的重复运算，我们创造一个数组，将计算过的步数放进去就行了。   
```c
class Solution  
{   
public:  
	int uniquePaths(int m, int n)   
	{  
		if (ret.size() < m)  
		{   
			//由于数组从0开始，为了避免不必要的混淆，我们对于m和n我们多申请一列，同时我们不使用数组【0】的纵向横向的第一列。    
			for (int i = 0; i < m+1; i++)  
			{   
				vector<int> temp(n + 1, -1);	//所有值初始化为-1  
				ret.emplace_back(temp);   
			}   
		}  

		if (m == 1|| n==1)   
		{  
			return ret[m][n] = 1;  
		}   

		if (ret[m - 1][n] <0 )  
			ret[m - 1][n] = uniquePaths(m - 1, n);   
		if (ret[m][n - 1] <0 )   
			ret[m][n - 1] = uniquePaths(m, n - 1);   

		return ret[m - 1][n] + ret[m][n - 1];   
	}  
private:   
	vector<vector<int>> ret;   
};   
```  
通过使用数组来存储数值，时间复杂度已经降到了O(n)。   
### 迭代终极版
最终版本意味着我们将根据之前的模型重构思路，不再从最后开始，也不再使用递归。我们根据之前整理的思路和数学公式，将其转变为从前向后，简单的迭代。   
![](https://github.com/sii2017/image/blob/master/leetcode62_1.jpg)  
根据图片我们可以得知：  
1 在计算之前，我们就能知道，最左边和最上边两条边上的方块的路径数量都为1且只能为1。   
2 当我们把两条边设置好值以后，那么[1][1]位置的值就可以根据[0][1]+[1][0]来计算出来了，以此类推，整个表格（数组）的值都可以计算出来。  
3 我们最终要返回的仅仅是ret也就是[m-1][n-1]这个位置的值，因此当我们计算出整个表格的值后，返回最后一个就可以了。   
```c
class Solution   
{   
public:  
	int uniquePaths(int m, int n)    
	{  
		if (m == 0 || n == 0)  
			return 1;    
		vector<vector<int>> ret(m, vector<int>(n, 0));   
		for (int i = 0; i < m; i++)  //先用1填满一条边   
		{  
			ret[i][0] = 1;  
		}  
		for (int i = 0; i < n; i++)   //再用1填满另外一条边   
		{  
			ret[0][i] = 1;   
		}  
		for (int i = 1; i < m; i++)   //根据已知的两条边计算所有的值   
		{   
			for (int j = 1; j < n; j++)   
			{   
				ret[i][j] = ret[i - 1][j] + ret[i][j - 1];   
			}  
		}    
		return ret[m - 1][n - 1];  //返回需要的值   
	}  
};    
```   
动态规划做到第三步，总是让我觉得有些抽象了，可能自己的数学思维还不够吧，目前的我必须要借助前两步来推敲。  
但是无论如何，当推敲到第三步的时候，有柳暗花明又一村的喜悦感。   
不同路径问题到此结束。   