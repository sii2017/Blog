# 动态规划算法
## 爬楼梯
这里借用leetcode的一道基础的动态规划的题目来做例子。   
> 70.爬楼梯   
> 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。   
> 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？   

> 注意：给定 n 是一个正整数。   

> 示例 1：    
> 输入： 共2阶楼梯      
> 输出： 有两种方法可以爬到楼顶。        
> 解释：     
> 1.  1 阶 + 1 阶   
> 2.  2 阶   
  
> 示例 2：    
> 输入： 共3阶楼梯       
> 输出： 有三种方法可以爬到楼顶。      
> 解释：      
> 1.  1 阶 + 1 阶 + 1 阶  
> 2.  1 阶 + 2 阶  
> 3.  2 阶 + 1 阶   
### 模型
思路如下：   
1 打个比方我们要计算10阶台阶的情况下，有多少种方式。   
2 从最后开始看，我们走到第10阶台阶有几种方式？   
答：两种，一种是从9阶走到10，一种是从8阶走到10。   
3 那么我们假设dp[n]代表走到n阶阶梯的方式数量。dp[10]=dp[9]+dp[8]。是的，我们走到10阶只有两种方式，一种是从9到10，一种是从8到10。   
4 以此类推，我们再往前推，到走到台阶9有几种方式？走到台阶8有几种方式？  
答：各为两种。走到台阶9分别是从台阶7走和台阶8走。dp[9]=dp[8]+dp[7]。走到台阶8分别是从台阶7走和台阶6走。dp[8]=dp[7]+dp[6]。   
5 我们可以推导出一个公式：dp[n]=dp[n-1]+dp[n-2]。   
6 显然台阶数为0的时候，方法为0。台阶数为1的时候方法为1。台阶数为2的时候方法为2。我们可以写代码了。   
### 代码
```c
class Solution   
{  
public:   
	int climbStairs(int n)  
	{  
		if (n < 1)   //如果台阶小于1，即为0，方式也为0   
			return 0;   
		else if (n == 1)  //如果台阶等于1，那么只有一种方式  
			return 1;   
		else if (n == 2)   //如果台阶等于2，那么只有2种方式   
			return 2;   
		//其余的通过递归来进行运算  
		return climbStairs(n - 1) + climbStairs(n - 2);   
	}   
};   
```   
### 代码优化版
```c
class Solution {   
public:   
    int climbStairs(int n) {   
        if (dp.size() < n)   
			dp.insert(dp.begin(), n+1, -1);   

		if (n < 1)    
			return 0;   
		else if (n == 1)  
			return 1;   
		else if (n == 2)    
			return 2;   

		if (dp[n - 1] < 0)   
		{   
			dp[n - 1] = climbStairs(n - 1);   
		}   
		if (dp[n - 2] < 0)   
		{   
			dp[n - 2] = climbStairs(n - 2);   
		}   
		dp[n] = dp[n - 1] + dp[n - 2];   
		return dp[n];   
    }   
private:  
    vector<int> dp;   
};    
```   