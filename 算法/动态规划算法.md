# 动态规划算法
以下从易到难的通过一些例题来介绍动态规划。   
**这是野路子。正规路子请看《算法导论》。**   
动态规划算法当中包含了三个重要的概念：  
**1 最优子结构。**  
**2 边界。**   
**3 状态转移公式。**   
理论知识我就不多说了，因为理论知识我自己也有点晕。通过例题以及这三个重要的概念来理解动态规划吧。   
## 爬楼梯
这里借用leetcode的一道最基础的动态规划的题目来做例子。   
> 70.爬楼梯   
> 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。   
> 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？   

> 注意：给定 n 是一个正整数。   

> 示例 1：    
> 输入： 共2阶楼梯      
> 输出： 有两种方法可以爬到楼顶。        
> 解释：     
> 1.  1 阶 + 1 阶   
> 2.  2 阶   
  
> 示例 2：    
> 输入： 共3阶楼梯       
> 输出： 有三种方法可以爬到楼顶。      
> 解释：      
> 1.  1 阶 + 1 阶 + 1 阶  
> 2.  1 阶 + 2 阶  
> 3.  2 阶 + 1 阶   
### 模型
思路如下：   
1 打个比方我们要计算10阶台阶的情况下，有多少种方式。   
2 从最后开始看，我们走到第10阶台阶有几种方式？   
答：两种，一种是从9阶走到10，一种是从8阶走到10。   
3 那么我们假设dp[n]代表走到n阶阶梯的方式数量。dp[10]=dp[9]+dp[8]。是的，我们走到10阶只有两种方式，一种是从9到10，一种是从8到10。   
> 在这里。dp[9]和dp[8]就是dp[10]的**最优子结构**。   
    
4 以此类推，我们再往前推，到走到台阶9有几种方式？走到台阶8有几种方式？  
答：各为两种。走到台阶9分别是从台阶7走和台阶8走。dp[9]=dp[8]+dp[7]。走到台阶8分别是从台阶7走和台阶6走。dp[8]=dp[7]+dp[6]。   
5 我们可以推导出一个公式：dp[n]=dp[n-1]+dp[n-2]。   
> 在这里，dp[n]=dp[n-1]+dp[n-2]就是前面所说的**状态转移公式**。     
    
6 显然台阶数为0的时候，方法为0。台阶数为1的时候方法为1。台阶数为2的时候方法为2。   
> 在这里，dp[1]和dp[2]是我们能直接得出结果的，也就是动态规划里的**边界**。   
   
以上，我们可以写代码了。   
### 代码
```c
class Solution   
{  
public:   
	int climbStairs(int n)  
	{  
		if (n < 1)   //如果台阶小于1，即为0，方式也为0   
			return 0;   
		else if (n == 1)  //如果台阶等于1，那么只有一种方式  
			return 1;   
		else if (n == 2)   //如果台阶等于2，那么只有2种方式   
			return 2;   
		//其余的通过递归来进行运算  
		return climbStairs(n - 1) + climbStairs(n - 2);   
	}   
};   
```   
但是这个代码有一个问题：效率。    
![](https://github.com/sii2017/image/blob/master/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%921.jpg)   
可以看到我们需要的方法是一颗二叉树，而节点的数量就是我们需要计算的次数，为2的n平方。   
![](https://github.com/sii2017/image/blob/master/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922.jpg)   
由于其中有不少重复的计算，因此我们可以将计算过的数值放入map或者数组中，直接使用可以节省相当多的算力。  
### 代码优化版
```c
class Solution {   
public:   
    int climbStairs(int n) {   
        if (dp.size() < n)   
			dp.insert(dp.begin(), n+1, -1);   //扩容dp，并且全部置于-1   

		if (n < 1)    
			return 0;   
		else if (n == 1)  
			return 1;   
		else if (n == 2)    
			return 2;   

		if (dp[n - 1] < 0)   
		{   
			dp[n - 1] = climbStairs(n - 1);   
		}   
		if (dp[n - 2] < 0)   
		{   
			dp[n - 2] = climbStairs(n - 2);   
		}   
		dp[n] = dp[n - 1] + dp[n - 2];   
		return dp[n];   
    }   
private:  
    vector<int> dp;   
};    
```   
由于每一步计算后都会被保存下来，保证每一步只有一次计算，因此时间复杂度就变成了n。  
### 代码优化终极版
上一个版本的代码已经比较优秀了，第一个版本的代码在运行n=30时花费时间6秒，而上一个版本的代码只花费了1秒不到。   
而这个终极版再次优化，体现在两点：
1 使用迭代替代递归，进一步优化空间效率和时间效率。   
2 不再需要通过vector或者map来记录，进一步优化空间效率。   
**具体思路如下：**   
在之前的概念中，我们已经知道，走到第十阶的数量是由走到第八阶和走到第九阶两个数量加起来决定的，并且可以以此往下推。   
那么我们是不是能从前往后推呢？   
我们可以确定的是：走到第一阶只有一种方法， 走到第二阶只有两种方法。因此我们知道，走到第三阶的方法是1+2=3。那我们以此类推不就知道往后的数字了吗?   
![](https://github.com/sii2017/image/blob/master/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%923.jpg)   
```c
class Solution {   
public:  
	int climbStairs(int n)    
	{   
		if (n < 1)  
			return 0;  
		if (n == 1)  
			return 1;  
		if (n == 2)   
			return 2;  

		int a = 1;   //替代n-2，并且在迭代中更新数值  
		int b = 2;   //替代n-1，并且在迭代中更新数值   
		int temp;   //替代n的方法总是，等于a+b，并且在迭代中更新数值  
		for (int i = 3; i < n + 1; i++)  
		{  
			temp = a + b;  
			a = b;  
			b = temp;   
		}  
		return temp;  //迭代结束后，temp就是最终的步数了  
	}   
};  
```     
时间复杂度为O(n），空间复杂度为O(1)。   
爬楼梯案例到这里就结束了。   
## 不同路径 
来源：leetcode   
这是继我完成上一道题后，独立完成的第二道题。其中“递归普通版”和“递归优化版”已经可以独立完成了，而“最终优化版”的模型还是参考了其它人的思路。   
题目如下：   
> 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。   
> 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。   
> 问总共有多少条不同的路径？    
   
![](https://github.com/sii2017/image/blob/master/leetcode62.png)   
> 示例 1:   
> 输入: m = 3, n = 2  
> 输出: 3   
> 解释:   
> 从左上角开始，总共有 3 条路径可以到达右下角。  
> 1. 向右 -> 向右 -> 向下   
> 2. 向右 -> 向下 -> 向右  
> 3. 向下 -> 向右 -> 向右   
  
> 示例 2:  
> 输入: m = 7, n = 3  
> 输出: 28   
### 递归低效版
这是最简单的建立模型的方式。   
与上一个案例一样，从最后开始考虑。达到(m,n)的路线数量是由什么决定的？   
由于题目规定，只能朝右或者朝下进行移动，达到(m,n)只有两种途径，一种是从(m-1,n)来，一种是从(m,n-1)来。   
因此达到(m,n)路线的数量就是“到达(m-1,n)路线的数量”加上“到达(m,n-1)路线的数量”的总和，并且以此往前类推。   
我们设F(m,n)为到达(m,n)的路线的数量。   
那么我们可以得出这么一个公式：F(m,n)= F(m-1,n)+F(m,n-1)。  
> F(m-1,n)和F(m,n-1)就是F(m,n)的**最优子结构**以及F(m,n)= F(m-1,n)+F(m,n-1)就是**状态转移公式**。    
    
有关于这个问题的边界是什么？  
那就是当m或者n为1的时候，也就是在地图上贴边了，这时候就不用再往前计算了。一方面1也无法再减1，另外一方面，贴边了就注定只有一条路线了，那就是从起点贴着边直接过来。   
> 因此，F(m,n)= 1 (如果m=1||n=1)；就是**边界**了。   
      
根据这个模型，我们可以写代码了。   
```c
class Solution  
{  
public:  
	int uniquePaths(int m, int n)   
	{  
		if (m == 1)  //如果m为1，说明已经贴最左边，只有一条路线了。   
			return 1;  
		if (n == 1)  //如果n为1，说明已经贴最右边，只有一条路线了。   
			return 1;   

		return uniquePaths(m - 1, n) + uniquePaths(m, n - 1);   //根据公式，通过递归将前面的两种路线的合加起来   
	}   
};   
```   
这个递归是最容易理解的，同时他也有着和上一题同样的问题，它会进行很多重复的计算，时间复杂度会达到指数级，因此，我们进入下一步的优化。   
### 递归优化版
递归的优化版还是很好理解的，由于会进行巨量的重复运算，我们创造一个数组，将计算过的步数放进去就行了。   
```c
class Solution  
{   
public:  
	int uniquePaths(int m, int n)   
	{  
		if (ret.size() < m)  
		{   
			//由于数组从0开始，为了避免不必要的混淆，我们对于m和n我们多申请一列，同时我们不使用数组【0】的纵向横向的第一列。    
			for (int i = 0; i < m+1; i++)  
			{   
				vector<int> temp(n + 1, -1);	//所有值初始化为-1  
				ret.emplace_back(temp);   
			}   
		}  

		if (m == 1|| n==1)   
		{  
			return ret[m][n] = 1;  
		}   

		if (ret[m - 1][n] <0 )  
			ret[m - 1][n] = uniquePaths(m - 1, n);   
		if (ret[m][n - 1] <0 )   
			ret[m][n - 1] = uniquePaths(m, n - 1);   

		return ret[m - 1][n] + ret[m][n - 1];   
	}  
private:   
	vector<vector<int>> ret;   
};   
```  
通过使用数组来存储数值，时间复杂度已经降到了O(n)。   
### 迭代终极版
最终版本意味着我们将根据之前的模型重构思路，不再从最后开始，也不再使用递归。我们根据之前整理的思路和数学公式，将其转变为从前向后，简单的迭代。   
![](https://github.com/sii2017/image/blob/master/leetcode62_1.jpg)  
根据图片我们可以得知：  
1 在计算之前，我们就能知道，最左边和最上边两条边上的方块的路径数量都为1且只能为1。   
2 当我们把两条边设置好值以后，那么[1][1]位置的值就可以根据[0][1]+[1][0]来计算出来了，以此类推，整个表格（数组）的值都可以计算出来。  
3 我们最终要返回的仅仅是ret也就是[m-1][n-1]这个位置的值，因此当我们计算出整个表格的值后，返回最后一个就可以了。   
```c
class Solution   
{   
public:  
	int uniquePaths(int m, int n)    
	{  
		if (m == 0 || n == 0)  
			return 1;    
		vector<vector<int>> ret(m, vector<int>(n, 0));   
		for (int i = 0; i < m; i++)  //先用1填满一条边   
		{  
			ret[i][0] = 1;  
		}  
		for (int i = 0; i < n; i++)   //再用1填满另外一条边   
		{  
			ret[0][i] = 1;   
		}  
		for (int i = 1; i < m; i++)   //根据已知的两条边计算所有的值   
		{   
			for (int j = 1; j < n; j++)   
			{   
				ret[i][j] = ret[i - 1][j] + ret[i][j - 1];   
			}  
		}    
		return ret[m - 1][n - 1];  //返回需要的值   
	}  
};    
```   
动态规划做到第三步，总是让我觉得有些抽象了，可能自己的数学思维还不够吧，目前的我必须要借助前两步来推敲。  
但是无论如何，当推敲到第三步的时候，有柳暗花明又一村的喜悦感。   
不同路径问题到此结束。   
## 最大子序和
同样是leetcode的题目。   
> 53 最大子序和
> 给定一个整数数组nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回最大和。   
> 实例：
> 输入：-2,1,-3,4,-1,2,1,-5,4。   
> 输出：6。   
> 解释：其中连续子数组4，-1，2，1的和最大，为6。  
### 模型  
这道题也可以从后往前想，但是对于我来说，从前往后思考更容易理解。因此它的思考方式与前两道题有所不同，思路如下：  
1 首先我们创造一个数组，dp[size]来存放从开始到每个数字的最大和。比如dp[0]就是范围0-0的最大和的值，只有一个数字因此为-2。再比如dp[1]是范围0-1的最大和的值，因为-2小于0，那么不加这个-2，dp[1]为1。      
2 这时候会有疑问，我们求的是**某一段连续的且和为最大的值**，并不是从头到某个字的最大和的值。   
3 实际上是一样的，比如1，-2，1，3这么一个数组，到3的最大的和为4，因为前2个加起来是-1，因此后面加上他们总会边小，所以就不加他们。也就是说若dp[i-1]小于0，则dp[i]加上前面的任意长度的序列和都会小于不加前面的序列。        
4 对于我们的例子数组，首先nums[0]肯定是范围0-0的最大值，因此dp[0]为-2。   
5 nums[1]为1，由于位置1之前的值的总和（虽然只有-2一个）为负数，因此不要去添加，从1开始重新计算。dp[1]为1。   
6 nums[2]为-3，由于位置2之前的值的总和dp[1]是1，大于0，因此加上可以使数字更大，-3+1=-2。   
7 以此类推。   
### 代码
```c
class Solution   
{  
public:   
	int maxSubArray(vector<int>& nums)   
	{  
		int size = nums.size();  
		if (size == 0) return 0;   
		else if (size == 1) return nums[0];   
		vector<int> dp;  

		for (int i = 0; i < size; i++)   
		{  
			if (dp.empty())   //如果dp为空，说明在计算第一个元素，那么把这个元素直接存进去   
				dp.emplace_back(nums[i]);  
			else if (dp[i - 1] > 0)  //看dp的前一个元素是否大于0，大于0则加上现在这个村入，小于0则只存入当前数     
				dp.emplace_back(nums[i] + dp[i - 1]);   
			else   
				dp.emplace_back(nums[i]);  
		}     
		sort(dp.begin(), dp.end());   
		return dp.back();  
	}   
};   
```   
这个代码已经是O(n)的效率了，实际上它的思考方式也可以像前两个例子一样倒着来，不过对于我来说正着思考更方便理解。   
最大子序和，结束。   
