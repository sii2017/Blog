## GO TOUR moretypes
> GO指南中moretypes部分   
   
### 指针
Go 拥有指针。指针保存了值的内存地址。   
类型 *T 是指向 T 类型值的指针。其零值为 nil。   
```
var p& int
```   
& 操作符会生成一个指向其操作数的指针。  
```
i:=43  
p=&i   
```   
\* 操作符表示指针指向的底层值。   
```
fmt.Printfln(*p)    //通过指针p读取i   
*p=21 	//通过指针p设置i   
```    
与C不同，GO没有指针运算。   
### 结构体
一个结构体就是一段字段。   
```
type Vertex struct{
	X int    
	Y int  
}   
```   
### 结构体字段
结构体字段使用点号来访问   
```
v:=Vertex{1,2}   
v.X=4   
```   
### 结构体指针  
结构体字段可以通过结构体指针来访问。   
如果我们有一个指向结构体的指针 p，那么可以通过 (*p).X 来访问其字段 X。不过这么写太啰嗦了，所以语言也允许我们使用隐式间接引用，直接写 p.X 就可以。    
```
v := Vertex{1, 2}  
p := &v  
p.X = 1e9   
```  
### 结构体文法
结构体文法通过直接列出字段的值来新分配一个结构体。  
使用 Name: 语法可以仅列出部分字段。（字段名的顺序无关。）   
特殊的前缀 & 返回一个指向结构体的指针。   
```
var (  
	v1 = Vertex{1, 2}  // 创建一个 Vertex 类型的结构体    
	v2 = Vertex{X: 1}  // Y:0 被隐式地赋予   
	v3 = Vertex{}      // X:0 Y:0   
	p  = &Vertex{1, 2} // 创建一个 *Vertex 类型的结构体（指针）  
)  
```  
### 数组
类型 [n]T 表示拥有 n 个 T 类型的值的数组。   
```
var a [10]int   
```   
会将变量 a 声明为拥有 10 个整数的数组。   
数组的长度是其类型的一部分，因此数组不能改变大小。这看起来是个限制，不过没关系，Go 提供了更加便利的方式来使用数组。   
### 切片
每个数组的大小都是固定的。而切片则为数组元素提供动态大小的、灵活的视角。在实践中，切片比数组更常用。  
类型 []T 表示一个元素类型为 T 的切片。  
切片通过两个下标来界定，即一个上界和一个下界，二者以冒号分隔：   
```
a[low : high]  
```   
它会选择一个半开区间，包括第一个元素，但排除最后一个元素。  
以下表达式创建了一个切片，它包含 a 中下标从 1 到 4 的元素：   
```
primes := [6]int{2, 3, 5, 7, 11, 13}
var s []int = primes[1:4]
```   
切片并不存储任何数据，它只是描述了底层数组中的一段。   
更改切片的元素会修改其底层数组中对应的元素。   
与它共享底层数组的切片都会观测到这些修改。  
切片就像数组的引用。   
### 切片用法
切片文法类似于没有长度的数组文法。   
这是一个数组文法：   
```
[3]bool{true, true, false}   
```   
下面这样则会创建一个和上面相同的数组，然后构建一个引用了它的切片：   
```   
[]bool{true, true, false}   
```  
可以看出切片的声明和使用几乎与数组一模一样，并且可以代替数组。   
### 切片的默认范围 
在进行切片时，你可以利用它的默认范围来忽略上下界。   
切片下界的默认值为 0，上界则是该切片的长度。    
对于数组   
```
var a [10]int  
```
来说，以下切片是等价的：   
``` 
a[0:10]   
a[:10]  
a[0:]  
a[:]  
```   
### 切片的长度与容量
切片拥有 长度 和 容量。   
> 我们假设切片有左指针和右指针。   
  
切片的长度就是它所包含的元素个数。   
> 同时，切片的长度，是左指针到右指针之间元素的数量     
   
切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数。    
> 更容易理解的方式来说，切片的容量是左指针，到最后一个元素的元素数量   
   
切片 s 的长度和容量可通过表达式 len(s) 和 cap(s) 来获取。   
如果想增加切片的容量，我们必须创建一个新的更大的切片并把原分片的内容都拷贝过来。  
### nil切片
切片的零值是 nil。   
nil 切片的长度和容量为 0 且没有底层数组。   
```
var s []int   
fmt.Println(s, len(s), cap(s))  
if s == nil {   
	fmt.Println("nil!")  
}   
```   
### 用make创建切片
切片可以用内建函数 make 来创建，这也是你创建动态数组的方式。   
make 函数会分配一个元素为零值的数组并返回一个引用了它的切片：   
```
a := make([]int, 5)  // len(a)=5   
```   
要指定它的容量，需向 make 传入第三个参数：   
```
b := make([]int, 0, 5) // len(b)=0, cap(b)=5   
b = b[:cap(b)] // len(b)=5, cap(b)=5   
b = b[1:]      // len(b)=4, cap(b)=4   
```  
### 切片的切片
切片可包含任何类型，甚至包括其它的切片。   
### 向切片追加元素
为切片追加新的元素是种常用的操作，为此 Go 提供了内建的 append 函数。   
```
func append(s []T, vs ...T) []T
```
append 的第一个参数 s 是一个元素类型为 T 的切片，其余类型为 T 的值将会追加到该切片的末尾。  
append 的结果（返回值）是一个包含原切片所有元素加上新添加元素的切片。   
如果s的底层数组太小，不足以容纳所有给定的值时，它就会分配一个更大的数组。返回的切片会指向这个新分配的数组。   
### Range
for 循环的 range 形式可遍历切片或映射。
当使用 for 循环遍历切片时，每次迭代都会返回两个值。第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本。   
```
var pow = []int{1, 2, 4, 8, 16, 32, 64, 128}  
func main() {  
	for i, v := range pow {   
		fmt.Printf("2**%d = %d\n", i, v)  
	}   
}  
```  
可以将下标或值赋予 _ 来忽略它。   
```
for i, _ := range pow   
for _, value := range pow  
```  
若只需要索引，忽略第二个变量即可。   
```
for i := range pow     
```   
### 映射
映射将键映射到值。比如map类型。   
映射的零值为 nil 。nil 映射既没有键，也不能添加键。   
make 函数会返回给定类型的映射，并将其初始化备用。   
```
var m map[string]Vertex   
m = make(map[string]Vertex)   
m["Bell Labs"] = Vertex{   
		40.68433, -74.39967,   
	}   
```   
映射的文法与结构体相似，不过必须有键名。   
### 修改映射
在映射 m 中插入或修改元素：   
```
m[key] = elem   
```   
获取元素：   
```
elem = m[key]   
```   
删除元素：   
```
delete(m, key)   
```   
通过双赋值检测某个键是否存在：   
```
elem, ok = m[key]   
```   
若 key 在 m 中，ok 为 true ；否则，ok 为 false。   
若 key 不在映射中，那么 elem 是该映射元素类型的零值，即nil。   
同样的，当从映射中读取某个不存在的键时，结果是映射的元素类型的零值。   
注 ：若 elem 或 ok 还未声明，你可以使用短变量声明：   
```
elem, ok := m[key]   
```   
### 函数值
函数也是值。它们可以像其它值一样传递。   
函数值可以用作函数的参数或返回值。      
### 函数的闭包
Go 函数可以是一个闭包。   
闭包是一个函数值，它引用了其函数体之外的变量。该函数可以访问并赋予其引用的变量的值，换句话说，该函数被这些变量“绑定”在一起。  
> 闭包就是一个函数与其相关的引用环境组成的一个整体。   
闭包本质其实是一个函数，但是这个函数会用到函数外的变量，它们共同组成的整体我们叫做闭包。   
   
```
func AddUpper () func (int) int {  
    var n int = 10   
    return func (x int) int {   
        n = n + x  
        return n   
    }  
}   
```
以上，函数内包含函数，且返回值为函数的函数称为闭包。   
闭包通常的使用方法如下   
```
func main(){

    test := AddUpper() //test变量接收Addupper返回的函数  

    fmt.Println(test(1))  //11  
 
    fmt.Println(test(2))   //13   

    fmt.Println(test(3))    //16  
}  
```   
值得一提的是，外部函数AddUpper以赋值的形式被赋值给了test，因此该函数内的参数n只被初始化一次，并且始终隐式存在于test中。   
后面对于n产生叠加，所以当传入2和3的时候分别是13和16   
