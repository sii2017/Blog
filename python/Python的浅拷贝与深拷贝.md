## Python的浅拷贝与深拷贝
在《Python的引用传递和值传递方式》说过，对于可变类型数据，python通过赋值也好，还是函数传参，都是无法进行完全的拷贝的，通常只是传送了原值的引用。   
那么通过什么方法可以进行真正的拷贝，拷贝出一个独立的新的值呢？   
那就是copy模块中的copy方法了。   
### 普通的赋值
对于不可变类型数据，通过等号赋值，是可以开辟一个新的内存空间，获得一个新的独立的数据。    
然而，对于可变类型而言，通过等号赋值，仅仅是添加了一个引用，如果a赋值给b，当我们改变b的时候，a也会跟着改变。这显然和我们想的赋值是不一样的。   
比如这里的set。   
```Python
set1 = {1, 2, 3, 4, 5}
set2 = set1
set2.update({9, 10})

print(set1)     # {1, 2, 3, 4, 5, 9, 10}
print(set2)     # {1, 2, 3, 4, 5, 9, 10}

print(id(set1))     # 2599866580552
print(id(set2))     # 2599866580552
```
因此，当我们想拷贝一份新的独立的可变类型数据时，要使用copy方法。   
### （浅）拷贝方法   
浅拷贝，既可以通过对象自带的copy方法来实现，也可以通过copy模块的copy方法来实现。   
他们可以给被赋值的变量开拓一块新的内存空间，使其独立。    
```Python
set1 = {1, 2, 3, 4, 5}
set2 = copy.copy(set1)      # copy模块的copy方法
set3 = set1.copy()      # set自带的copy方法

set3.update({12, 13})
set2.update({10, 20})

print(set1)     # {1, 2, 3, 4, 5}
print(set2)     # {1, 2, 3, 4, 5, 20, 10}
print(set3)     # {1, 2, 3, 4, 5, 12, 13}

print(id(set1))     # 2476661980744
print(id(set2))     # 1408474748072
print(id(set3))     # 3085402785160
```  
可以看到，无论是通过set自带的copy，还是通过copy模块的copy方法，都能获得一个全新的set2和set3，分别有着独立的数据空间和内存地址。   
**但是这样，真的没有问题吗？**     
浅拷贝在一部分情况下是没有问题的，但是会有其自己的瓶颈存在。   
```Python
list1 = [1, 2, 3, [4, 5]]
list2 = copy.copy(list1)      # copy模块的copy方法

list2[3][1] = 2
list2[0] = 15

print(list1)     # [1, 2, 3, [4, 2]]
print(list2)     # [15, 2, 3, [4, 2]]

print(id(list1))     # 2376596190216
print(id(list2))     # 2376596180936

# 可以看到list1和list2第四个元素的地址是相同的  
print(id(list1[3]))     # 2376596186760
print(id(list2[3]))     # 2376596186760
```   
可以看到，当list1中嵌套了另外一个list时，copy虽然为list2开辟了一块新的内存空间，所以list1和list2的地址是不同的。   
list1和list2的第一个元素显然已经分开了。   
但是问题在于，list1和list2的第四个元素，仍然是相互关联，相互引用的情况。   
这是由于，尽管浅拷贝会为数据另外开辟一个内存空间，但是仅仅赋值了原数据下面的元素，而嵌套的list并不是一个元素，可以理解为是一个引用地址，也可以理解是是一个内存地址。   
所以浅拷贝仅仅拷贝了这个地址，并没有拷贝其中的实际内容，因此嵌套的list仍然是互相引用的关系，互相关联。   
为了解决这个问题，我们就该用到深拷贝了。   
### 深拷贝
深拷贝，顾名思义，可以将内存里嵌套的内存内容也全部拷贝过去，而不仅仅是拷贝一个地址。   
我们通常使用copy模块的deepcopy来实现。   
```Python
list1 = [1, 2, 3, [4, 5]]
list2 = copy.deepcopy(list1)      # copy模块的deepcopy方法

list2[3][1] = 2
list2[0] = 15

print(list1)     # [1, 2, 3, [4, 5]]
print(list2)     # [15, 2, 3, [4, 2]]

print(id(list1))     # 1668530903560
print(id(list2))     # 1668530894408

print(id(list1[3]))     # 1668530894536
print(id(list2[3]))     # 1668530894920
```    
通过id我们可以看到，无论是list1和list2本身，还是他们各自的第四个嵌套list的地址都不相同。   
如果说，我们要对一些嵌套的复杂数据类型进行拷贝，应该使用深拷贝。   
浅拷贝在使用的时候会带来意想不到的问题。  
### 浅拷贝与深拷贝的效率  
虽然说，深拷贝在所有情况下都能保证完全的拷贝，而浅拷贝在拷贝复杂数据的时候会无法拷贝嵌套的内容。   
但是浅拷贝仍然是有存在的意义的，浅拷贝的效率是远高于深拷贝的。   
```Python
list1 = []
for i in range(1000):
    list1.append(i)

for i in range(100000):
    list2 = copy.copy(list1)

for i in range(100000):
    list2 = copy.deepcopy(list1)
```   
上面的代码中做了一个实验，对于同样list1的拷贝：   
当我们使用浅拷贝，拷贝十万次，耗时0.6秒。   
当我们使用深拷贝，拷贝十万次，耗时108秒。  
由于python捉急的性能，并不建议无脑使用深拷贝，在必要的时候使用浅拷贝是可以提高效率的。   