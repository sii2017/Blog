## 模块管理
python中，每个文件就代表一个模块（module）。   
通常我们通过import module语句来导入一整个模块。   
但是如果模块中有同名语句，我们可以对import语句进行优化。   
### 模块管理同名函数
由于python中没有重载的概念，遇到同名函数则会产生歧义。   
理论上来说，无论是定义了同名函数还是导入了同名函数，后一个函数都会覆盖前一个，因此实际调用的是后一个函数。    
而在不同的模块中，我们可以有同名的函数，在使用函数的时候我们通过import关键字导入指定的模块就可以区分到底要使用的是哪个模块中的foo函数。   
#### 从不同模块导入函数
module1.py   
```
def foo():
	print('hello,world!')    
```   
module2.py
```
def foo():
	print('bye,world!')    
```    
test.py   

```
from module1 import foo   
# 这里输出hello，world   
foo()   

from module2 import foo   
# 这里输出bye，world   
foo()    
```
根据以上例子，我们可以看出，这个从其他module引入函数的语句有点像c++的using语句，可以随时使用，且作用效果可以被覆盖。    
格式基本上就是   
**from module import function**   
#### 导入并为不同模块定义别名
还有另外一种类似的方式来引入不同模块。   
```
import module1 as m1   
import module2 as m2   
m1.foo()   
m2.foo()    
```
很容易理解，这个写法有点像c++的对象。   
### 模块中其他可执行代码
需要注意的是，如果模块中除了定义函数以外，有一些其他的可执行代码。   
当我们导入这个模块的时候，python解释器会直接执行这些代码，在一些情况下我们并不想发生这些事情。   
这里引入一个概念\_\_name\_\_   
\_\_name\_\_是python中一个隐含的变量，它代表了当前模块的名字（以字符串的格式）。  
而如果一个模块被python解释器直接执行，它的名字会变成\_\_main\_\_   
因此我们可以用这么一个条件语句来防止其他模块的函数被误执行。   
```
if __name__ == '__main__'   
	# 其他代码   
```   
也就是说，如果这个\_\_name\_\_ 是main，也就意味着这个模块是由解释器直接执行的，那么它的这些代码才会被执行。   
如果这个模块是被导入的，那么它的\_\_name\_\_ 就不会是main，它的代码你不会被执行。    
