## 列表生成式和生成器
生成式和生成器是python中用来快速创建一个列表的操作。   
如果没有生成式和生成器，那么创建一个0-9的列表需要不断的循环，但是通过生成式或生成器，一下子就能生成了。   
### 生成式
生成式的语法为：[i for i in range(0,10)]   
**第一个i实际上是对每个值的修饰**，如果只是i则不修饰，如果需要对每个值进行处理则可以如下   
```Python
# 从0到9每个值都进行平方    
f= [i\*i for i in range(0,10)]  
print(f)    
# 从0到9每个值都进行乘以2   
f= [i\*2 for i in range(0,10)]   
print(f)    
```
**而第一个i后面实际上是一个python的for循环。**   
甚至在for循环后面还能加一个判断，比如   
```Python   
f= [i for i in range(0,10) if i%2==0]    
print(f)   
```   
以上生成式可以生成一个0-9中偶数的列表。   
### 生成器
通过生成器可以获取到数据但它不占用额外的空间存储数据。   
每次需要数据的时候就通过内部的运算得到数据(需要花费额外的时间)    
**我们可以将生成器看作一个方法，当需要调用它的时候，这个方法就即时演算一遍，生成一个临时的列表，用完消除**。  
生成器的语法，就是在生成式的基础上，将方括号变成圆括号，并且赋值给一个变量（也可称为方法）。   
f = (x ** 2 for x in range(1, 1000))   
值得注意的是，这个生成器并不能用来生成列表并赋值给列表。   
它只能现运算现用，并不能为列表赋值。   
以下行为是不能成功赋值的：    
```Python
f = (x ** 2 for x in range(1, 1000))   
list1= f   # useless
```   
那么生成器该怎么用呢？   
目前已知的方法为next函数。   
### next函数
```Python
print(next(f))   # 1
print(next(f))   # 4
print(next(f))   # 9
for x in range(1,3)  
	print(next(f))   # 16 25 36   
```   
可以看到初次调用next会从头开始获取该方法中第一个数，后面的next依次会读取下面的数值。   
那么next如何判断该取那个值呢？以及这个值的位置何是重置？   
```Python
f = (x ** 2 for x in range(1, 1000))
print(next(f))  # 1
print(next(f))	# 4
print(next(f))	# 9
for x in range(5,10):
    print(next(f))  # 16 25 26 49 64   

u = (x for x in range(5, 10))
print(next(u))   # 5
print(next(f))	 # 81
```  
根据以上测试，可以看到对其他方法使用next，再转回原来的方法不会改变其取值顺位。   
猜想next该函数应该维护着一个值，或者方法本身维护着一个值来给next使用。   
总而言之，next函数可以实时调用方法，来按顺序的获取生成式的值。   
### yield关键字
通过yield关键字可以把一个**函数**变成一个生成器，或可以称之为方法。   
```
def fun():   
    for x in range(100):   
        x += 2*x  
        yield x   


f = fun()   
for x in range(100):  
    print(next(f))  
```   
在给f赋值的那一步，并没有实际调用fun函数，只是返回了一个方法。   
而当打印的时候，才一步一步的在运行方法中的循环。   
值得留意的是，第一个next会从方法一开始运行到第一个yield，之后会在循环内不断循环到下一个yield的位置，直到没有循环了，将会从yield运行到该方法的结束处。   
但是目前看来，好像生成器更方便一些。   
详情可以参考同目录下《yield 关键字》   