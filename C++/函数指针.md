## 函数指针
 在C/C++中，数据指针是最直接，也最常用的，因此，理解起来也比较容易。而函数指针，作为运行时动态调用（比如回调函数 CallBack Function）是一种常见的，而且是很好用的手段。   
### 常规函数指针
```c
void (*fp)();		
```   
以上就是最简单的一种函数指针。指针变量的名称为fp，（*fp）代表这是一个函数指针而不是一般的函数，（）空的括号代表无参数，void代表返回值为void。   
```c
void (*fp2)(int);   
```   
同上，fp2是函数指针名称，参数为一个int，返回值为void。   
值得注意的是fp和fp2都只是一个空的函数指针，他们并未指向真正的函数。而我们需要将函数指针指向符合（参数和返回值）的函数，才能使用函数指针。   
```c
void f1()  
{  
	cout << "f1" << endl;   
}  
   
void f2(int a)  
{   
	cout << "f2" << endl;   
}  

fp= &f1;   //用fp指向f1，他们的参数一致   
fp2= &f2;  //用fp2指向f2，他们的参数一致   
```  
以上当函数指针指向函数后，才可以被使用。   
函数指针也像数据指针一样是可以重新指向其它函数的。   
```c
(*fp)();	//通过解引用调用   
fp();	//实际上不通过解引用也能调用    
(*fp2)(12);	//通过解引用调用      
fp(12);	//不解引用也可以    
```   
c++强调类型安全，也就是说，不同类型的变量是不能直接赋值的，否则轻则警告，重则报错。因此在给函数指针赋值的时候要注意返回值和参数相符。   
### 函数指针作为形参  
某些情况下，函数会以函数指针作为形参。   
```c
void func(int nValue, int pf(int,int));	//这个函数将函数类型作为形参，但是编译器会将其自动转换成指向函数的函数指针  

void func(int nValue, int (*pf)(int,int));	//与上面等价的声明，直接使用函数指针作为形参）   
void func(int nValue, fp2);	//如果函数指针已经声明过，也可以直接使用声明好的函数指针类型作为形参   
```   
### typedef和函数指针  
我们还可以用typedef来给函数指针取别名。   
```c
void function(int a);  	//比如有这么一个函数   
void (*fun)(int);	//我们如此定义一个函数指针，返回值是void，参数是int，函数指针变量名是fun       
fun= &function;	//我们将函数指针指向function函数   

void (*fun1)(int);	//我们定义第二个相同的函数指针，但是每次定义很麻烦，我们就可以使用typedef   
typedef void (*pfun)(int);    //我们将pfun作为该函数指针类型的别名   
pfun p1;   //等价于 void (*p1)(int)    
p1= &function;    
(*p1)(100);	//调用   
pfun p2;	//。。。。就可以比较方便的定义很多这个类型的指针了  
```   
如上所述，typedef可以帮我们“创建”一个函数指针的类型的别名，然后很方便的去声明同样的函数指针。    
> 这里的创建是引号，因为实际上typedef并不会创建任何东西，它永远只是给出一个别名。   
    
函数指针之所以让初学者畏惧，最主要的原因是它的括号太多了；某些用途的函数指针，往往会让人陷在括号堆中出不来。typedef方法可以有效的减少括号的数量，以及理清层次，所以受到推荐。    
### EXTRA
c++标准库模板的sort函数，使用函数作为第二个参数。   
```c
bool less(int a, int b)    
{   
	return a<b;  
}    

vector<int> nums= {...};      
sort(nums.begin(), nums.end(), less);    
```   
less就是我们经常说的回调(CallBack)函数，另外，操作系统中也经常使用回调函数，实际上，所谓回调函数，**本质就是函数指针**。    