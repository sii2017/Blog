## 二叉排序树
二叉排序树（Binary Sort Tree），又称二叉查找树（Binary Search Tree），亦称二叉搜索树。   
### 定义
二叉树可以具有以下的性质：  
1 可以为空，即空树。  
2 若左子树不空，则左子树上的所有节点的值均小于它的根节点。   
3 若右子树不空，则右子树上的所有节点的值均大于它的根节点。   
4 左右子树也分别都是二叉排序树。   
5 没有键值相等的节点。   
> 二叉排序树与一般二叉树的区别就在于节点上值的位置分配，普通的二叉树的值是自由分配的，但是二叉排序树要求，左子树上的值总是小于根节点，而根节点上的值总是小于右子树上的值。   
### 二叉排序树的样例
以下图为例，我们根据特定的顺序以及数值创建一颗符合二叉排序树的二叉树。   
![](https://github.com/sii2017/image/blob/master/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.jpg)   
```c
#include <iostream>     
#include <vector>   
using namespace std;  

struct TreeNode  
{  
	int val;   
	TreeNode* left, *right;  
	TreeNode(int p) : val(p), left(NULL), right(NULL) {}   
};   

class BinarySortTree  
{  
public:   
	BinarySortTree():root(NULL) {};  
	~BinarySortTree() {};   

	void CreateTree(vector<int>& vecParam);  
	void InsertNode(int num);  
private:   
	TreeNode * root;  
};   

//创建二叉树   
void BinarySortTree::CreateTree(vector<int>& vecParam)  
{   
	if (vecParam.empty())  
		return;   
	for (int i = 0; i < vecParam.size(); i++)  
	{   
		InsertNode(vecParam[i]);    
	}	  
}  

//插入节点   
void BinarySortTree::InsertNode(int num)  
{   
	if (!root)   
	{  
		root = new TreeNode(num);   
		return;   
	}   
	else  
	{  
		TreeNode* node = root;   
		while (node)  
		{  
			if (node->val > num)   
			{ 
				if(node->left)  
					node = node->left;    
				else   
				{   
					node->left = new TreeNode(num);   
					return;  
				}   
			}  
			else   
			{   
				if(node->right)    
					node = node->right;  
				else   
				{   
					node->right = new TreeNode(num);   
					return;    
				}  
			}   
		}  
	}   
}   

int main() 
{   
	vector<int> param = { 8,3,1,6,4,7,10,14,13 };   
	BinarySortTree bst;  
	bst.CreateTree(param);   
	getchar();  
	return 0;   
}   
```   
Create函数中通过遍历的使用InsertNode来完成全部元素的插入。为了符合二叉排序树的特点，在插入的同时进行数值的比较，保证左边小，右边大。   
### 查找
### 插入
之前在建立二叉排序树的时候使用过插入的函数。  
```c
void BinarySortTree::InsertNode(int num)  
{   
	if (!root)  
	{  
		root = new TreeNode(num);  
		return;  
	}   

	TreeNode* node = root;   
	while (node)   
	{  
		if (node->val > num)  //如果比根节点小，那么就往左边放   
		{  
			if (node->left)   //如果左子树有值，那么继续往下遍历   
				node = node->left;  
			else  //如果左子树无值，那么就放这里了。   
			{   
				node->left = new TreeNode(num);  
				return;   
			}  
		}  
		else  //如果比根节点，那么就往右边放    
		{   
			if (node->right)   //如果右子树有值，那么继续遍历      
				node = node->right;  
			else  //如果右子树无值，那么就放这里了。   
			{   
				node->right = new TreeNode(num);   
				return;   
			} 
		}  
	}  
}   
```   
这个插入不难理解，根据值的大小来判断遍历的方向是向左还是向右，直到找到一个无值的节点进行赋值即可。   
### 删除
删除节点的话，需要考虑三种情况。  
### 遍历
### 总结