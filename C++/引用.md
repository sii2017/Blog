## 引用（Reference）  
定义引用的表示方法与定义指针相似，只是用&代替了*。   
引用（reference）是c++对c语言的重要扩充。引用就是某一变量（目标）的一个别名，对引用的操作与对变量直接操作完全一样。   
其格式为：类型 &引用变量名 = 已定义过的变量名。   
引用的特点：  
1 一个变量可取多个别名（被引用）。   
2 引用必须初始化。  
3 引用只能在初始化的时候引用一次，不能转变引用的对象。  
### 基础引用
```c
void TestReference1 ()    
{    
     int a = 1;    
     int& b = a;   
  
     a = 2;  //b也随之等于2了
     b = 3;  //a也随之等于3了
}  
```  
操作别名和原变量效果一致，且他们的值互相捆绑。  
### const引用
```c
void TestReference2 ()  
{  
     int d1 = 4;  
     const int & d2 = d1;  
     d1 = 5;//d1改变，d2的值也会改变。  
     //d2 = 6;//d2带有const属性，不能通过d2改变值    
  
     const int d3 = 1;  
     const int & d4 = d3;  
     //int& d5 = d3;  
     const int & d6 = 5;//只有常引用可以引用常量  
  
     double d7 = 1.1;  
     //int& d8 = d7;//d7是double类型，d8是int，d7赋值给 d8时要生成一个临时变量，也就是说d8引用的是这个带有常性的临时变量，所以不能赋值。  
     const int& d9 = d7;  
}  
```
使用const引用变量需要注意const属性。   
### 引用作为参数
一般来说，编译器会将函数的形参进行拷贝，生成一个临时的变量供函数使用。使用引用作为参数，有两个好处：  
1 使用引用，则编译器不需要拷贝生成临时变量，直接使用原来的变量，效率会高很多。   
2 使用引用，我们可以在函数体内直接对变量本身进行修改（如果需要的话）    
3 为了效率，并且如果我们不需要改变引用，可以使用const引用的组合。可以大大提升效率。   
```
//使用引用的话，不做临时拷贝，&的使用说明此处只是原参数的另一个名字而已，所以修改时直接在原参数的基础上修改变量值。  
void Swap (int& left, int& right)  
{  
     int temp = left;  
     right = left ;  
     left = temp ;  
}  

//如果不希望函数改变参数的值，则加上const   
void Function(const int& a, const int& b)   
{  
	a= 6;	//error,不能赋值   
}   
```  
### 引用作为返回值 
要以引用返回函数值，则函数定义时要按以下格式：   
类型标识符 &函数名（形参列表及类型说明）{函数体}   
1 以引用返回函数值，定义函数时需要在函数名前加&。   
2 用引用返回一个函数值的最大好处是，在内存中不产生被返回值的副本。    
```c
float temp; //定义全局变量temp   
   
float fn1(float r) //定义函数fn1，它以返回值的方法返回函数值   
{   
　temp=(float)(r*r*3.14);  
　return temp;  
}   

float& fn2(float r) //定义函数fn2，它以引用方式返回函数值   
{  
　temp=(float)(r*r*3.14);   
　return temp;    
}   

int main()   
{   
　float a=fn1(10.0); //系统生成要返回值的副本（即临时变量）  
　float &b=fn1(10.0); //可能会出错，返回值作为临时变量不能被引用  
　float c=fn2(10.0); //系统不生成返回值的副本，直接返回引用并进行赋值    
　float &d=fn2(10.0); //系统不生成返回值的副本，返回引用并被另一个引用初始化   
}   
```   
引用作为返回值，必须遵守以下规则：   
（1）不能返回局部变量的引用。局部变量会在函数返回后被销毁，因此被返回的引用就成为了"无所指"的引用，程序会进入未知状态。   
（2）不能返回函数内部new分配的内存的引用。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。即该何时使用delete释放它？   
（3）可以返回类成员的引用，但最好是const。主要原因是当对象的属性是与某种业务规则（business rule）相关联的时候，其赋值常常与某些其它属性或者对象的状态有关，因此有必要将赋值操作封装在一个业务规则当中。如果其它对象可以获得该属性的非常量引用（或指针），那么对该属性的单纯赋值就会破坏业务规则的完整性。   
### 引用和多态
引用是除指针外另一个可以产生多态效果的手段。这意味着，一个基类的引用可以指向它的派生类实例。    
```c
#include <windows.h>  
#include <iostream>  
using namespace std;  

class Base  
{  
public:   
	virtual void output()  
	{   
		cout << "out put is class Base" << endl;   
	}   
};  

class A: public Base   
{  
public:  
	virtual void output()  
	{   
		cout << "output is class A" << endl;  
	} 
};   

class B: public Base  
{  
public:   
	virtual void output()   
	{  
		cout << "output is class B" << endl;   
	}  
};   

struct C: public Base  
{   
	virtual void output()   
	{   
		cout << "output is struct C" << endl;  
	}  
};  

int main()   
{  
	A a;  
	B b;   
	C c;   
	Base& refBase1= a;  
	refBase1.output();	//output is class A   
	Base& refBase2= b;   
	refBase2.output();	//output is class B  
	Base& refBase3= c;   
	refBase3.output();	//output is class C    

	getchar();  
	return 0;    
}  
```   
关于多态可以查阅同目录下《多态》。       
### 总结
（1）在引用的使用中，单纯给某个变量取个别名是毫无意义的，引用的目的主要用于在函数参数传递中，解决大块数据或对象的传递效率和空间不如意的问题。    
（2）用引用传递函数的参数，能保证参数传递中不产生副本，提高传递的效率，且通过const的使用，保证了引用传递的安全性。
（3）引用与指针的区别是，指针通过某个指针变量指向一个对象后，对它所指向的变量间接操作。程序中使用指针，程序的可读性差；而引用本身就是目标变量的别名，对引用的操作就是对目标变量的操作。    
## Extra
这里有一些额外的内容，关于左值引用和右值引用。   
### 左值引用 
上面所说大部分内容，实际上指的都是左值引用。   
用法可以写作：  
Type& 左值引用名= 左值表达式;   
左值引用相当于把一个变量的地址付给另一个变量，这两个变量可以访问同一个内存。右值仅仅是一个在常量区的临时常量，并不具备如同左值可以通过地址取值的功能。   
```c
int& r= val+1;   //不合法，val+1是右值。   
const int& r= val+1;  //合法   
```  
常左值引用可以绑定右值。   
c++中临时变量默认const属性，所以只能传给const的引用。规定右值不能绑定到非 const 限定的左值引用。   
### 右值引用
引用本身是一个左值，因为它有名字，使用时左值引用和右值引用是相同的，当成普通变量使用。   
左值引用声明和右值引用声明后的变量都是一个引用，两者的区别在于：**左值引用需要一个左值来赋值，指向左值；右值引用需要一个右值来赋值，指向右值。**   
为了支持移动操作（包括移动构造函数和移动赋值函数），C++才引入了一种新的引用类型——右值引用，可以自由接管右值引用的对象内容。  
案例1：    
```c
int &&i = 1;  
int b = 2;   
cout << i << endl;  
i = b;   
cout << i << endl;  
//输出1 2  
```   
i绑定到了右值1，说明初始化时，右值引用一定要用一个右值表达式绑定。初始化之后，可以用左值表达式修改右值引用的所引用临时对象的值。   
从底层来说，i实际存储的是“临时对象1的地址”，随后i就如同正常的变量一样使用。   
案例2：    
```c
int&&temp =0;    
int&&i = temp; //error  
```   
右值初始化以后，就成为了正常的左值，因此就不再是右值，也无法被右值引用。   
案例3：   
```c
int &&temp = 0;   
int &&i = 1;  
i = temp;   
```   
右值初始化后就是正常的左值了，因此左值给左值赋值，是合法的操作。   
案例4：  
```c   
class A   
{  
public:   
    int b;  
    int a;  
    char c[256];   
};   
void f(A a)  
{   
    //。。。;   
}   

int main(int argc, char const *argv[])   
{  
    A &&a = A();   
    f(a);   
}   
```
这是一个稍微复杂一些的关于类的右值引用。  
A()生成一个临时变量，可以被赋值也可以被右值引用。右值引用后a成为了一个正常的左值，于是可以作为f()的参数。   
**小结：**  
1 右值引用，是对临时对象的一种引用，它是在初始化时完成引用的，但是右值引用不代表引用临时对象后就不能改变右值引用所引用对象的值，仍然可以在初始化后改变临时对象的值。   
2 对于引用类型，可以用于它所引用对象类型的可以用的地方（把它当成普通变量），只不过用到的值是它所引用的对象的值，它还可以用于移动构造或赋值函数的地方。   
3 尽管上面详述了右值引用的使用，但是事实上，“为了支持移动操作（包括移动构造函数和移动赋值函数），C++才引入了一种新的引用类型——右值引用，可以自由接管右值引用的对象内容”。关于“移动构造函数和移动赋值函数”可以看同类目下相关博客。   