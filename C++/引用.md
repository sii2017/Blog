## 引用（Reference）  
定义引用的表示方法与定义指针相似，只是用&代替了*。   
引用（reference）是c++对c语言的重要扩充。引用就是某一变量（目标）的一个别名，对引用的操作与对变量直接操作完全一样。   
其格式为：类型 &引用变量名 = 已定义过的变量名。   
引用的特点：  
1 一个变量可取多个别名（被引用）。   
2 引用必须初始化。  
3 引用只能在初始化的时候引用一次，不能转变引用的对象。  
### 基础引用
```c
void TestReference1 ()    
{    
     int a = 1;    
     int& b = a;   
  
     a = 2;  //b也随之等于2了
     b = 3;  //a也随之等于3了
}  
```  
操作别名和原变量效果一致，且他们的值互相捆绑。  
### const引用
const引用只读不能修改，与绑定对象是否为const无关。   
> const引用可绑定非const对象，该对象被修改，const引用也会被修改。只是不能修改这个const引用而已。   
   
```c
int i=50;   
const int& c_i= i;   
i= 60;	//这时候c_i也被修改   
```   
非const引用可读可修改，只可与非const对象绑定。   
非const引用只能绑定到与该引用同类型的对象，而const引用则可以绑定到不同但相关的类型对象或者是右值。   
```c
double d = 2.15;   
const int& j = d;	//绑定相近类型的左值  
cout << j << endl;	//2   
const int& h = d + 3;	//绑定表达式的临时值  
cout << h << endl;	//5  
const int& i = 1.34;	//绑定右值  
cout << i << endl;	//1   
```     
### 引用作为函数参数
一般来说，函数的传参分为两种，一种是值传递，一种是引用传递。   
值传递，编译器将传进来的参数进行拷贝，初始化给函数的新的参数变量。由于会进行一次拷贝，如果是复杂的结构，则会消耗不少的效率。   
引用传递，编译器以引用的形式绑定传进来的参数，换言之，不用进行拷贝，直接使用原来的参数。省了一次拷贝，即提高了效率。   
使用引用作为参数，有两个好处：  
1 使用引用，则编译器不需要拷贝生成临时变量，直接使用原来的变量，效率会高不少。      
2 使用引用，我们可以在函数体内直接对变量本身进行修改（如果需要的话），而不用引用想更改变量本身的话，就要用到指针了。        
3 为了效率，并且如果我们不需要改变引用，可以使用const引用的组合，可以提高效率。   
```
//使用引用的话，不做临时拷贝，&的使用说明此处只是原参数的另一个名字而已，所以修改时直接在原参数的基础上修改变量值。  
void Swap (int& left, int& right)  
{  
     int temp = left;  
     right = left ;  
     left = temp ;  
}  

//如果不希望函数改变参数的值，则加上const   
void Function(const int& a, const int& b)   
{  
	a= 6;	//error，不能赋值   
}   
```  
#### 针对const引用形参的优化 
一般情况下，我们使用值传递给函数传参的时候，即使类型不一样，只要符合转换的规则，都会隐式转换成符合的参数进行拷贝。   
但是使用引用形参，则不同类型的隐式转换是被禁止的。   
因为如果可以转换，则会生成一个转换后的临时对象，并且将函数内的引用参数绑定这个临时对象，但是临时对象是右值，引用不能绑定右值。比如：   
```c
void fun(int& i)  
{  
	cout << i << endl;  
}   

double d= 2.32;  
fun(d);	//error  
```   
不过，c++还是做了一定的让步和优化，当形参不是单纯的引用，而是带const属性的引用，则可以传递类型不同但接受隐式转换的参数。const引用可以绑定右值，const属性即意味着函数内部不会改变这个引用的内容，是安全的。   
```c
void fun(const int& i)   
{  
	cout << i << endl;   
}   

double c = 1.5;    
fun(c + 1);	//表达式转化成临时变量并通过引用传递   
fun(2.07);	//常量转换成临时变量并通过引用传递  
fun('z');	//字符转换成临时变量并通过引用传递   
```   
#### 对于类引用参数派生类的优化
c++中有一个概念是继承，它的一个特征是，基类引用可以指向派生类对象，而无需进行强制类型转换。    
这种特征的一个实际结果是，可以定义一个接收基类引用作为形参的函数。调用该函数时，可以将积累对象作为参数也可以将派生类对象作为参数。这都不会发生转换，而是直接使用的。   
```c
class human  //基类   
{  
public:  
	virtual void print()  
	{  
		cout << "human" << endl;   
	}  
};   

class woman :public human  //派生类  
{  
public:   
	virtual void print()  
	{  
		cout << "woman" << endl;   
	}   
};   

//以基类作为形参的函数   
void fun(human& m)   
{  
	m.print();  
}  

int main()  
{  
	human m1;  
	woman m2;  
	fun(m1);  //既可以以基类为实参   
	fun(m2);  //也可以以派生类为实参   
}    
```   
### 引用作为返回值  
要以引用返回函数值，则函数定义时要按以下格式：   
类型标识符 &函数名（形参列表及类型说明）{函数体}   
1 以引用返回函数值，定义函数时需要在函数名前加&。   
2 用引用返回一个函数值的最大好处是，在内存中不产生被返回值的副本。    
```c
float temp; //定义全局变量temp   
   
float fn1(float r) //定义函数fn1，它以返回值的方法返回函数值   
{   
　temp=(float)(r*r*3.14);  
　return temp;  
}   

float& fn2(float r) //定义函数fn2，它以引用方式返回函数值   
{  
　temp=(float)(r*r*3.14);   
　return temp;    
}   

int main()   
{   
　float a=fn1(10.0); //系统生成要返回值的副本（即临时变量）  
　float &b=fn1(10.0); //可能会出错，返回值作为临时变量不能被引用  
　float c=fn2(10.0); //系统不生成返回值的副本，直接返回引用并进行赋值    
　float &d=fn2(10.0); //系统不生成返回值的副本，返回引用并被另一个引用初始化   
}   
```   
引用作为返回值，必须遵守以下规则：   
（1）不能返回局部变量的引用。局部变量会在函数返回后被销毁，因此被返回的引用就成为了"无所指"的引用，程序会进入未知状态。   
（2）不能返回函数内部new分配的内存的引用。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。即该何时使用delete释放它？   
（3）可以返回类成员的引用，但最好是const。主要原因是当对象的属性是与某种业务规则（business rule）相关联的时候，其赋值常常与某些其它属性或者对象的状态有关，因此有必要将赋值操作封装在一个业务规则当中。如果其它对象可以获得该属性的非常量引用（或指针），那么对该属性的单纯赋值就会破坏业务规则的完整性。   
### 引用和多态
引用是除指针外另一个可以产生多态效果的手段。这意味着，一个基类的引用可以指向它的派生类实例。    
```c
#include <windows.h>  
#include <iostream>  
using namespace std;  

class Base  
{  
public:   
	virtual void output()  
	{   
		cout << "out put is class Base" << endl;   
	}   
};  

class A: public Base   
{  
public:  
	virtual void output()  
	{   
		cout << "output is class A" << endl;  
	} 
};   

class B: public Base  
{  
public:   
	virtual void output()   
	{  
		cout << "output is class B" << endl;   
	}  
};   

struct C: public Base  
{   
	virtual void output()   
	{   
		cout << "output is struct C" << endl;  
	}  
};  

int main()   
{  
	A a;  
	B b;   
	C c;   
	Base& refBase1= a;  
	refBase1.output();	//output is class A   
	Base& refBase2= b;   
	refBase2.output();	//output is class B  
	Base& refBase3= c;   
	refBase3.output();	//output is class C    

	getchar();  
	return 0;    
}  
```   
关于多态可以查阅同目录下《多态》。       
### 总结
（1）在引用的使用中，单纯给某个变量取个别名是毫无意义的，引用的目的主要用于在函数参数传递中，解决大块数据或对象的传递效率和空间不如意的问题。    
（2）用引用传递函数的参数，能保证参数传递中不产生副本，提高传递的效率，且通过const的使用，保证了引用传递的安全性。
（3）引用与指针的区别是，指针通过某个指针变量指向一个对象后，对它所指向的变量间接操作。程序中使用指针，程序的可读性差；而引用本身就是目标变量的别名，对引用的操作就是对目标变量的操作。    
## Extra
这里有一些额外的内容，关于左值引用和右值引用。   
### 左值引用 
上面所说大部分内容，实际上指的都是左值引用。   
用法可以写作：  
Type& 左值引用名= 左值表达式;   
左值引用相当于把一个变量的地址付给另一个变量，这两个变量可以访问同一个内存。右值仅仅是一个在常量区的临时常量，并不具备如同左值可以通过地址取值的功能。   
```c
int& r= val+1;   //不合法，val+1是右值。   
const int& r= val+1;  //合法   
```  
常左值引用可以绑定右值。   
c++中临时变量默认const属性，所以只能传给const的引用。规定右值不能绑定到非 const 限定的左值引用。   
### 右值引用
引用本身是一个左值，因为它有名字，使用时左值引用和右值引用是相同的，当成普通变量使用。   
左值引用声明和右值引用声明后的变量都是一个引用，两者的区别在于：**左值引用需要一个左值来赋值，指向左值；右值引用需要一个右值来赋值，指向右值。**   
为了支持移动操作（包括移动构造函数和移动赋值函数），C++才引入了一种新的引用类型——右值引用，可以自由接管右值引用的对象内容。  
案例1：    
```c
int &&i = 1;  
int b = 2;   
cout << i << endl;  
i = b;   
cout << i << endl;  
//输出1 2  
```   
i绑定到了右值1，说明初始化时，右值引用一定要用一个右值表达式绑定。初始化之后，可以用左值表达式修改右值引用的所引用临时对象的值。   
从底层来说，i实际存储的是“临时对象1的地址”，随后i就如同正常的变量一样使用。   
案例2：    
```c
int&&temp =0;    
int&&i = temp; //error  
```   
右值初始化以后，就成为了正常的左值，因此就不再是右值，也无法被右值引用。   
案例3：   
```c
int &&temp = 0;   
int &&i = 1;  
i = temp;   
```   
右值初始化后就是正常的左值了，因此左值给左值赋值，是合法的操作。   
案例4：  
```c   
class A   
{  
public:   
    int b;  
    int a;  
    char c[256];   
};   
void f(A a)  
{   
    //。。。;   
}   

int main(int argc, char const *argv[])   
{  
    A &&a = A();   
    f(a);   
}   
```
这是一个稍微复杂一些的关于类的右值引用。  
A()生成一个临时变量，可以被赋值也可以被右值引用。右值引用后a成为了一个正常的左值，于是可以作为f()的参数。   
**小结：**  
1 右值引用，是对临时对象的一种引用，它是在初始化时完成引用的，但是右值引用不代表引用临时对象后就不能改变右值引用所引用对象的值，仍然可以在初始化后改变临时对象的值。   
2 对于引用类型，可以用于它所引用对象类型的可以用的地方（把它当成普通变量），只不过用到的值是它所引用的对象的值，它还可以用于移动构造或赋值函数的地方。   
3 尽管上面详述了右值引用的使用，但是事实上，“为了支持移动操作（包括移动构造函数和移动赋值函数），C++才引入了一种新的引用类型——右值引用，可以自由接管右值引用的对象内容”。关于“移动构造函数和移动赋值函数”可以看同类目下相关博客。   