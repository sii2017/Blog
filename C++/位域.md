## 位域
有些信息在存储时，并不需要占用一个完整的字节，而只需占几个或一个二进制位。   
例如在存放一个开关量时，只有0和1两种状态，用一位二进位即可。   
为了节省存储空间，并使处理简便，C/C++语言又提供了一种数据结构，称为“位域”或“位段”。    
所谓“位域”是把一个字节中的二进制位划分为几个不同的区域，并说明每个区域的位数。    
每个域有一个域名，允许在程序中按域名进行操作。这样就可以把几个不同的对象用一个字节的二进制位域来表示。    
### 位域的定义和使用方式
位域的定义和位域变量的说明位域定义与结构定义相仿，其形式为：  
```c
struct st   
{   
	int a: 4;	//assign 4 bits  
	int b: 1;	//assign 1 bits  
	int c: 8;    
}  
```   
st的声明方式表明，a并不像一般的int占用4个字节/32位，而是仅仅占用4位。同理b只占用1位，而c占用8位即一个字节。   
由于声明的int为带符号类型，因此符号会占用一位。  
那么st::a的4位仅仅只有3位能存储数字，即-8到7的取值范围。而b只有1位，并且用来存储符号位了，它只有-1到0的取值范围。   
如果我们将int声明为unsigned int，作为无符号整数，那么他们的取值范围会大大提高。a会变成0到15；b则是0到1。   
### 需要注意的地方  
1 位域总是从字的第一个位开始；   
2 位域不能与整数的边界重叠，重叠域将字段作为下一个字的开始。   
3 位域的大小不能大于这个类型本身的最大字段，即int如果设置33则无法通过编译。   
4 可以给未命名的域声明大小，一般用来填充空白位置来调整域的分布。比如：  
```c  
struct st  
{  
	int a: 4;  
	int  : 4;  
}  
```  
5 不能使用位域变量的地址，这也意味着不能使用scanf函数将数值读入位域（可以使用中间变量赋值的方法来解决）。   
6 也不能使用位域变量的地址来访问位域。   
7 位域不能数组化。   
8 位域必须进行赋值（即明确分配的位数），而且所赋的值必须在位域的大小范围之内，过大会发生不可预知的错误。   
9 位域定义中的数据类型如果是signed，那么其位数就不能少于两位（因为其中一个是符号位）。    
10 无法对位域的值进行sizeof操作。   
> 早期计算机内存匮乏，因此使用位域来进一步缩小内存的使用，现在动辄几百G，应该已经不需要了。但是仍旧作此记录。   
