## alloca malloc calloc realloc
之前面试遇到过这个问题，由于基本不怎么用这些函数，没答上。现在学习并且记录一下。   
先概括的说，都是与分配内存有关。
第一个是在栈分配内存，后面三个是在堆分配内存。   
### alloca
alloca是向栈申请内存，因此无需释放。    
功能：返回一个指向n个连续字符存储单元的指针。利用afree§释放已经分配的存储空间，以便以后使用。   
函数原型: char *alloc(int n);   
由于离开调用alloca的函数之后，该内存就会被自动释放，不具有可移植性，所以不推荐使用。   
### malloc   
memeory allocation，动态内存分配        
malloc分配的内存是位于堆中的，并且没有初始化内存的内容，因此基本上malloc之后，调用函数memset来初始化这部分的内存空间。     
**功能：**用于申请一块连续的指定大小的内存块区域以void*类型返回分配的内存区域地址。   
#### 工作机制
malloc函数的实质体现在，他有一个将可用的内存块连接为一个长长的链表的所谓空闲链表。调用malloc函数是，他沿着连接表寻找一个大到足以满足用户请求所需要的内存块。然后，将该内存块一分为二（一块的大小与用户请求的大小相等，另一块的大小就是剩下的字节）。接下来，将分配给用户的那块内存传给用户，并将剩下的那块（如果有的话）返回到连接表上。调用free函数时，他将用户释放的内存块连接到空闲链表上。到最后，空闲链会被切成很多的小内存片段，如果这时用户申请一个大的内存片段，那么空闲链上可能没有满足用户要求的片段了。于是，malloc函数请求延时，并开始在空闲链上，检查各个内存片段，对他们进行整理，将相邻的小空闲块合并成较大的内存块。如果无法获得符合要求的内存块，malloc函数会返回NULL指针，因此在调用malloc动态申请内存块时，一定要进行返回值的判断。     
**注意总结：**  
1. 使用malloc一定要判断返回值是否为NULL。   
2. 使用malloc要用memset初始化。    
函数原型： void *malloc(unsigned int size)   
### calloc
calloc则是在malloc的基础上，将申请的内存初始化为0。  
函数原型：void *calloc(unsigned int num,unsigned int size);  
**功能：**在内存的动态存储区中分配n个长度为size的连续空间，函数返回一个指向分配起始地址的指针；如果分配不成功，返回NULL。  
num：对象个数，size：对象占据的内存字节数。   
相较于malloc函数，calloc函数会自动将内存初始化为0。而malloc不做初始化，分配到空间中的数据是随机数据。   
### realloc
realloc对申请的内存进行大小的调整，申请的内存最终也需要通过函数free来释放。    
函数原型：extern void *realloc(void *mem\_address,unsigned int newsize);   
**功能：**先判断当前的指针是够有足够的连续空间。    
如果有，扩大mem_address指向的地址，并且将mem_address返回；   
如果空间不够，先按照newsize指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来mem\_address所指内存区域(注意：原来指针是自动释放，不需要使用free)，同时返回新分配的内存区域的首地址。   
**注意事项：**    
1 **原先的地址如果放弃使用是会被自动释放的。不要手动的free否则会造成内存泄露**。    
2 newsize小于原先的大小的时候，可能会造成数据丢失。   
3 mem\_address一定要是malloc，calloc或realloc申请得到指针。    
4 如果newsize大小为0，那么释放mem_address指向的内存，并返回NULL。这里需要注意的是只对指针本身进行释放，例如对二维指针**a，对a调用realloc时只会释放一维，使用时谨防内存泄漏。   
5 如果没有足够可用的内存用来完成重新分配（扩大原来的内存块或者分配新的内存块），则返回NULL。而原来的内存块保持不变。    
6 传递给realloc的指针可以为空，效果等同于malloc。    