## socket编程 recv函数
不论是客户还是服务器应用程序都用recv函数从TCP连接的另一端接收数据。    
```c
int recv( SOCKET s, char FAR *buf, int len, int flags);     
```
参数：   
第一个参数指定接收端套接字。    
第二个参数指明一个缓冲区，该缓冲区用来存放recv函数接收到的数据；   
第三个参数指明buf的长度；   
第四个参数一般置0。   
### recv函数的执行流程
（1）recv先等待s的发送缓冲中的数据被协议传送完毕，如果协议在传送s的发送缓冲中的数据时出现网络错误，那么recv函数返回SOCKET\_ERROR。    
（2）如果s的发送缓冲中没有数据或者数据被协议成功发送完毕后，recv先检查套接字s的接收缓冲区，如果s接收缓冲区中没有数据或者协议正在接收数据，那么recv就一直等待，直到协议把数据接收完毕。当协议把数据接收完毕，recv函数就把s的接收缓冲中的数据copy到buf中（注意协议接收到的数据可能大于buf的长度，所以 在这种情况下要调用几次recv函数才能把s的接收缓冲中的数据copy完。**recv函数仅仅是copy数据，真正的接收数据是协议来完成的**）。   
（3）recv函数返回其实际copy的字节数。如果recv在copy时出错，那么它返回SOCKET_ERROR；如果recv函数在等待协议接收数据时网络中断了，那么它返回0。    
注意：在Unix系统下，如果recv函数在等待协议接收数据时网络断开了，那么调用recv的进程会接收到一个SIGPIPE信号，进程对该信号的默认处理是进程终止。   
tcp协议本身是可靠的，并不等于应用程序用tcp发送数据就一定是可靠的。不管是否阻塞，send发送的大小，并不代表对端recv到多少的数据。   