## static关键字
static的作用主要有以下两种:   
1 限定作用域    
2 保持变量内容持久化    
3 如果对全局变量使用，则将全局变量的外部链接性转变为内部链接性，即将其作用域由全部文件转变为本文件才能使用。   
### 全局静态变量
在全局变量前加上关键字static，全局变量就定义成一个全局静态变量。     
```c
static int temp；   
```
内存中的位置：静态存储区，在整个程序运行期间一直存在。   
初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）。   
作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。   
### 局部静态变量 
在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。   
内存中的位置：静态存储区。   
初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）。    
作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变。    
### 静态成员变量
```c
class A    
{   
private:   
	static int val;   
};   
```
在cpp中必须对他进行初始化，初始化时使用作用域运算符来标明他所属类，并不需要加static关键字。其属于该类的所有成员共有，只有一个拷贝；   
```c   
//cpp   
int A::val= 15;   
```
### 静态函数
在函数返回类型前加关键字static，函数就定义成静态函数。函数的定义和生命在默认情况下都是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。   
```c
class A   
{   
private:   
	static int func(int x);  
};     
```
实现的时候也不需要static的修饰，因为static是声明性关键字。   
类的静态函数是该类的范畴内的全局函数，不能访问类的普通成员，只能访问类的静态成员，不需要类的实例即可调用。    
> 这是因为静态函数及静态成员在类实例化之前就已经存在了，因此它不能访问未实例化的其他成员，如果其他成员未实例化则会发生内存泄漏。  
    
实际上，他就是增加了类的访问权限的全局函数。   
静态成员函数可以继承和覆盖，但无法是虚函数。   
### 勿在头文件中定义static变量
定义全局变量时使用static，意味着该变量的作用域只限于定义它的源文件中，其它源文件不能访问且**不可见**。   
如果有多个文件都包含了该头文件，那么该头文件被包含了多少次，这些变量就定义了多少次。    
由于静态变量互相不可见，因此编译器也并不能察觉该变量被重定义了，而是多次进行了定义。此时这并不是同一个静态变量而是多个不同的静态变量，如果出现这样的错误难以察觉且容易影响业务逻辑。   
静态函数同理。   