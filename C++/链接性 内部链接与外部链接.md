## 链接性 内部链接与外部链接
在c++primer中看到关于const和static的内链接性的说明，由此扩展并记录关于c++内部链接和外部链接的内容。   
### 编译单元
一个cpp文件就是一个编译单元。   
当一个c或cpp文件在编译时，预处理器首先递归包含头文件，形成一个含有所有必要信息的单个源文件，这个源文件就是一个编译单元。   
事实上每个编译单元都是相互独立的，即每个cpp文件之间并不知道对方的存在。  
编译器会分别将每个编译单元（.cpp）进行编译，生成相应的obj文件。   
然后链接器会将所有的obj文件进行链接，生成最终的可执行文件。   
### 内部链接和外部链接 
内部连接：   
如果一个名称对编译单元(.cpp)来说是局部的，在链接的时候其他的编译单元无法链接到它且不会与其它编译单元(.cpp)中的同样的名称相冲突。例如static对象，inline函数等。   
外部连接：   
如果一个名称对编译单元(.cpp)来说不是局部的，而在链接的时候其他的编译单元可以访问它，也就是说它可以和别的编译单元交互。例如全局变量，以及普通的函数。       
### 函数的链接性
全局变量以及普通的函数，默认是extern的。   
关于extern可以参考同目录下《关键字 extern》。   
我们知道c++中声明和定义是可以分开的。我们可以在一个a.cpp中声明一个函数，然后在b.cpp中定义这个函数。然后我们仍旧能在a.cpp中通过b.cpp中的定义来使用这个函数。   
这是由于，尽管cpp之间是互不可见的，但是编译器在编译的时候会分析不同的cpp，将其能提供给其它编译单元使用的**外连接性**的函数、变量的定义记录下来，以及将自己有过声明，但是没有定义的函数、变量记录下来。   
然后编译器在不同的编译单元间进行匹配，给每个声明寻找名字匹配的定义，来使用。   
因此，我们在使用标准库提供的函数时，只要包含其头文件就可以了。   
可以理解为，编译器将头文件里的函数声明全部复制到包含这个头文件的cpp的顶部；  
然后在编译的时候，编译器看到了这些声明，但是没有找到定义，因此先记录下来；  
随后在链接的时候，编译器在其它的编译单元中寻找匹配的函数定义，最终在该头文件对应的cpp文件中找到了函数定义。通过链接，最终在可执行文件中，我们可以看到函数的运行。   
普通变量也是同理。   
### 内部链接
以下内容具有内部链接性，即它的名称对于它的编译单元是局部的，并且链接时不会与其它的编译单元中同样的名字冲突。  
1 静态（static）全局变量，自由函数，友元函数定义    
2 常属性（const）对象   
3 内联函数定义  
4 Union共用体定义   
5 名字空间的const常量定义  
6 枚举类型定义   
7 所有的声明（有人将声明归结为无链接）  
8 类的定义   
需要注意的是，声明是个比较特殊的东西，它本身是无链接/内链接性的，即不会跟其它编译单元中相同名字的声明产生冲突。但是它可以帮助本编译单元访问其它编译单元里的相关定义。   
### 外部链接
以下实体具有外部链接性，也就是说这个实体可以与其它编译单元中，同样具有外部链接性的实体进行交互，以及冲突。   
1 类的非内联函数（包括成员函数和静态类成员函数）的定义   
2 类的静态成员变量的定义  
3 名字空间或全局的非静态的自由函数，非静态变量，非友元函数的定义  
4 extern对象  
### 宏的链接属性
宏不具有链接属性，它在预处理环节就被替换掉了，而链接性是针对编译环节与链接环节的。   
### const和static关键字   
static能让全局变量变为内部连接性。   
const也能让全局变量变为内部链接性。  