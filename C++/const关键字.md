## const关键字
const是C++中常用的类型修饰符，常类型是指使用类型修饰符const说明的类型，常类型的变量或对象的值需要直接被初始化，并且是不能被改变的。   
### const的作用
**1 定义const常量**    
该常量需要直接被初始化，且不能被改变。   
> 也由于常量无法被修改，所以必须初始化。   
    
```c
const int Max = 100;   
```   
**2 便于进行类型检查**   
const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查，而对后者只进行字符替换，没有类型安全检查，并且在字符替换时可能会产生意料不到的错误。     
```c    
void f(const int i) { .........}//对传入的参数进行类型检查，不匹配进行提示   
```
**3 可以保护被修饰的内容**    
强制进行保护，防止意外的修改，增强程序的健壮性。    
```c
void f(const int i)   
{     
	i=10;//error! 如果在函数体内修改了i，编译器就会报错   
}   
```   
**4 可以很方便地进行参数的调整和修改**   
同宏定义一样，可以做到不变则已，一变都变。    
**5 为函数重载提供了一个参考**    
```c   
class A  
{    
           //......   
  void f(int i)       {......} //一个函数   
  void f(int i) const {......} //上一个函数的重载版本   
           //......   
};   
```   
**6 可以节省空间，避免不必要的内存分配**   
const定义常量（函数体外）从汇编的角度来看，只是给出了对应的内存地址，而不是像#define一样立刻分配空间。直到const常量（函数体外）被引用，才分配内存。   
函数体内的const常量与其他变量一样属于栈式分配，会直接分配内存。         
```c   
#define PI 3.14159         //常量宏      
const doulbe  Pi=3.14159;  //此时并未给Pi分配内存      
              ......   
double i=Pi;   //此时为Pi分配内存，以后不再分配！  
double I=PI;  //编译期间进行宏替换，分配内存    
double j=Pi;  //没有内存分配   
double J=PI;  //再进行宏替换，又一次分配内存！     
```   
**7 提高了效率**   
编译器通常不为全局const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。   
当然函数体内的const常量是与其他变量一样分配内存的。   
### const的使用
**1、定义常量**   
(1)const修饰变量，以下两种定义形式在本质上是一样的。它的含义是：const修饰的类型为TYPE的变量value是不可变的。   
```c
TYPE const ValueName = value;   
const TYPE ValueName = value;   
```    
(2)将const改为外部连接,作用于扩大至全局,编译时会分配内存,并且可以不进行初始化,仅仅作为声明,编译器认为在程序其他地方进行了定义.
```c
extend const int ValueName = value;   
```
**2、指针使用const**   
(1)指针本身是常量不可变   
```c
char* const pContent;    
```
(2)指针所指向的内容是常量不可变    
```
const char *pContent;    
```
(3)两者都不可变   
```
const char* const pContent; 
```
(4)还有其中区别方法，沿着*号划一条线：   
如果const位于*的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；   
如果const位于*的右侧，const就是修饰指针本身，即指针本身是常量。    
**3、函数中使用const**   
(1)const修饰函数参数    
a.传递过来的参数在函数内不可以改变。   
```c
void function(const int Var);   
```  
b.参数指针所指内容为常量不可变   
```c
void function(const char* Var);    
```
c.参数指针本身为常量不可变    
```c
void function(char* const Var);    
```
d.参数为引用，为了增加效率同时防止修改。   
```c
void function(const Class& Var); //引用参数在函数内不可以改变
```
这样的一个const引用传递和最普通的函数按值传递的效果是一模一样的,他禁止对引用的对象的一切修改,唯一不同的是按值传递会先建立一个类对象的副本, 然后传递过去,而它直接传递地址,所以这种传递比按值传递更有效。   
另外只有引用的const传递可以传递一个临时对象,因为临时对象都是const属性, 且是不可见的,他短时间存在一个局部域中,所以不能使用指针,只有引用的const传递能够捕捉到这个家伙。   
(2)const 修饰函数返回值。  
const修饰函数返回值其实用的并不是很多，它的含义和const修饰普通变量以及指针的含义基本相同。   
```c
const int fun1() //这个其实无意义，因为参数返回本身就是赋值。

const int * fun2()	//返回的指针指向的内容为const，非指针const   
const int *pValue = fun2(); //我们可以把fun2()看作成一个变量，即指针指向的内容不可变。   

int* const fun3()//返回的指针不可变       
int * const pValue = fun2();//我们可以把fun2()看作成一个变量，即指针本身不可变。   
```
一般情况下，函数的返回值为某个对象时，如果将其声明为const时，多用于操作符的重载。通常，不建议用const修饰函数的返回值类型为某个对象或对某个对象引用的情况。原因如下：如果返回值为某个对象为const（const A test = A 实例）或某个对象的引用为const（const A& test = A实例） ，则返回值具有const属性，则返回实例只能访问类A中的公有（保护）数据成员和const成员函数，并且不允许对其进行赋值操作，这在一般情况下很少用到。   
**4、类相关const**   
(1)const修饰成员变量   
const修饰类的成员变量，表示成员常量，不能被修改，也不能赋值初始化，因为const数据成员只在某个对象生存期内是常量，类的对象未被创建时，编译器不知道const 数据成员的值是什么。**它只能在初始化列表中赋值**。   
```c
class A   
{   
	//…    
	const int nValue; //成员常量不能被修改   
	const int nValue= 100;	//错误，类内不能直接初始化const常量  
	A(int x): nValue(x) { } ; //只能在初始化列表中赋值   
}   
```   
(2)const修饰成员函数   
const修饰类的成员函数，则该成员函数不能修改类中任何非const成员函数。一般写在函数的最后来修饰。   
```c
class A
{ 
	void function()const; //常成员函数, 它不改变对象的成员变量，也不能调用类中任何非const成员函数。    
}    
```
对于const类对象/指针/引用，只能调用类的const成员函数，因此，const修饰成员函数的最重要作用就是限制对于const对象的使用。   
a. const成员函数不被允许修改它所在对象的任何一个数据成员。
b. const成员函数能够访问对象的const成员，而其他成员函数不可以。
(3)const修饰类对象/对象指针/对象引用    
const修饰类对象表示该对象为常量对象，其中的任何成员都不能被修改。对于对象指针和对象引用也是一样。    
const修饰的对象，**该对象的任何非const成员函数都不能被调用**，因为任何非const成员函数会有修改成员变量的企图。    
### 将Const类型转化为非Const类型的方法
采用const_cast进行转换。   
变量本身的const属性是不能去除的，要想修改变量的值，一般是去除指针（或引用）的const属性，再进行间接修改。   
用法：const_cast <type_id>  (expression)    
常量指针被转化成非常量指针，并且仍然指向原来的对象；  
常量引用被转换成非常量引用，并且仍然指向原来的对象；   
常量对象被转换成非常量对象。   
```c
#include<iostream>
using namespace std;

void ConstTest1()   
{    
    const int a = 5;   
    int *p;  
    p = const_cast<int*>(&a);    
    (*p)++;   
    cout<<a<<endl;   
    cout<<*p<<endl;    
}    

void ConstTest2()    
{  
    int i;   
    cout<<"please input a integer:";   
    cin>>i;   
    const int a = i;   
    int &r = const_cast<int &>(a);    
    r++;   
    cout<<a<<endl;   
}   

int main()   
{   
    ConstTest1();  
    ConstTest2();  
    return 0;   
}   
```
输出：  
5   
6      
若输入7  
则输出8   
**小结：**  
1 原const常量的const属性是无法被去除的。   
2 const_cast通过曲线救国的方式，以引用或指针修改const常量所在的内存来改变其值。   
3 const常量所在的内存的值实际是被改变了，但是通过将其赋值给别的变量仍然是原来的数值，这是因为常量折叠造成的。编译器将原来符号对应的数值直接替换在该位置，而没有重新使用内存里实际的值。   
4 原const常量由于常量折叠，它被调用的时候永远是原来的值。但是通过指针或者引用经由转换后，我们可以得知该内存里的值确实可以被改变。   
### 改变全局变量链接性
一般情况下，全局变量的链接性为外部，即其他的文件中都可以通过   
```c
extern tpye name;   
```   
来使用这个文件中的全局变量。   
而当我们给全局变量加const关键字，与static关键字的作用相同，这个全局变量的链接性变成了内部，即只有本文件里代码可以使用这个全局变量，其他文件里的代码无法使用它了。   
### const常量的内存分配
C++的编译器通常在编译期间为普通const常量分配存储空间，并且将它们保存在符号表中，这使得它成为一个编译期间的常量。   
当我们使用const常量时，并不会有存储与读内存的操作，而是直接进行符号表中的数值替换在使用的地方，使得它的效率很高。   