## c++11 关键字 noexcept
### noexcept说明符
对于用户及编译器来说，预先知道某个函数不会抛出异常，有助于简化调用该函数的代码；其次编译器如果能确认哈桉树不会抛出异常，则可以执行某些特殊的优化操作（这些优化操作可能并不适用于可能出错的代码）。   
在c++11中，我们可以通过提供noexcept指定某个函数不会抛出异常。其形式是关键字noexcept紧跟在函数的参数列表后面，用以标识该函数不会抛出异常。   
#### 使用方式
```c
void fun1(int) noexcept;	//不会抛出异常    
void fun2(int);	//可能抛出异常   
```  
noexcept说明符需要跟在const及引用限定符之后，而在final、override或虚函数的=0之前。   
如果一个函数标识为noexcept，那么最好保证它内部调用的任何函数也不会抛出异常。当然了，如果内部有系统调用，这也是没有办法百分之一百保证的。   
#### 违反异常说明
编译器本身并不会在编译的时候检查noexcept说明是否符合实际情况。   
因此如果一个函数在说明了noexcept之后，仍然抛出了异常，程序会调用terminate——>abort以确保遵守不在运行时抛出异常的承诺。    
#### 异常说明的实参
noexcept接受一个可选的实参，实参必须能转化为bool类型。  
如果实参为true，则说明该函数不会抛出异常；如果实参为false，则说明可能抛出异常。 
### noexcept运算符
noexcept还能作为运算符来使用。noexcept运算符是一个一元运算符，它的返回值是一个bool类型的右值常量表达式，用于表时给定的表达式是否会抛出异常。  
```c
void fun1(int) noexcept;	//不会抛出异常    
void fun2(int);	//可能抛出异常   
bool b1= noexcept(fun1(i));		//true表示fun1不会抛出任何异常   
bool b2= noexcept(fun2(i));		//false表示fun2可能抛出异常   
```  
### noexcpt说明符和运算符的结合使用   
我们可以结合noexcept运算符和说明符得到如下的异常说明：   
```c
void fun() noexcept(noexcept(g());   
```  
如果函数g承诺了不会抛出异常，那么noexcept运算符（第二个）会返回true，因此noexcept运算符（第一个）会得到一个true的参数，导致fun也做出了不会抛出异常的承诺。   
反之亦然。   
如此结合可以保证两个函数保持一致的异常承诺。   
### extra
noexcept说明符遵守“承诺收束规则”（我自己编的）。   
也就是说，如果一个函数做出了不抛出异常承诺，那么如果有指针指向它，该指针必须也做出不抛出异常承诺。   
相反，如果一个函数没有做出承诺，是一个可抛可不抛的状态，那么无论函数指针是否声明了noexcept，都可以指向它。   
另外对于虚函数来说，如果一个虚函数承诺了noexcept，则后续派生出来的虚函数也必须相同；相反，如果一个虚函数允许抛出异常，那么派生类的对应函数可以允许抛出异常，也可以声明不允许抛出异常。   