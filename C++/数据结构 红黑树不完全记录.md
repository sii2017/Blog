## 红黑树
红黑树（Red-Black-Tree），是二叉排序树的优化版本。是一颗自平衡的二叉排序树。   
红黑树对二叉排序树的最差情况有一个保底，即当二叉排序树成为一个链表的时候，它的效率将为O(n)，而拥有自平衡功能的红黑树能保证它自身大致是平衡的，因此它的保底效率为O(logn)。   
红黑树在很多地方都有应用。在C++ STL中，很多部分(包括set, multiset, map, multimap)应用了红黑树的变体。   
### 红黑树的构成
```c  
struct red_black_tree    
{    
	int val;    
	red_black_tree* left, *right, *parent;    
	int color;	   
}  
```     
红黑树的构成与二叉排序树不同的地方在于，它多包含了两个变量，一个是指向双亲的指针，一个是颜色。   
什么是颜色呢？来看红黑树的性质。   
### 红黑树的性质 
红黑树拥有五条性质。  
1）每个结点要么是红的，要么是黑的。   
2）根结点是黑的。   
3）每个叶结点，即空结点（NIL）是黑的。  
4）如果一个结点是红的，那么它的俩个儿子都是黑的。   
5）对每个结点，从该结点到其子孙结点的所有路径上包含相同数目的黑结点。    
这些约束强制了红黑树的关键性质: 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。   
要知道为什么这些特性确保了这个结果，注意到性质4导致了路径不能有两个毗连的红色节点就足够了。最短的可能路径都是黑色节点，最长的可能路径有交替的红色和黑色节点。因为根据性质5所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。    
在一般的树中，叶子节点也是包含数据的，但是在红黑树中，叶子节点是第一个不包含数据的空节点，并且根据上面第三条性质，这个叶子节点总是黑色的。   
### 旋转1
在添加元素的过程中，有可能会**违反红黑树的五条性质**。这种情况下，我们需要对当前节点以及它周围的节点的位置进行调整，来使之可以保持红黑树的性质。   
这种调整称为旋转，旋转分为左旋和右旋。他们是对称的，只要了解其一，就能了解其二。   
![](https://github.com/sii2017/image/blob/master/%E5%B7%A6%E6%97%8B%E5%92%8C%E5%8F%B3%E6%97%8B.png)   
从上图可以看出，左旋就是把当前节点变为父节点，而原来的父节点变成当前节点的左节点。   
右旋同理，把当前节点变成父节点同时把父节点变成当前节点的右节点。   
然后根据元素的大小（这有规律可循），把他们重新分配相应的位置。   
总的来说，这是一个小范围内，以旋转为基调的位置重新分配。旋转后，作为二叉搜索树的性质没有改变。同时就这个范围内，满足红黑树的五条性质。   
不过旋转后有一定概率，会造成向上的一个范围内的树结构再次违反红黑树的五条性质，我们循环向上检查并旋转即可。这也是旋转的意义：如果我们仅仅调整当前范围内的颜色，确实可以使当前范围内满足性质，但是他们会影响到周围的树结构，因此按规律的旋转是效率最高也最安全的方法。   
### 旋转2
插入情况一、右节点插入：  
![](https://github.com/sii2017/image/blob/master/%E6%97%8B%E8%BD%AC1.png)  
![](https://github.com/sii2017/image/blob/master/%E6%97%8B%E8%BD%AC2.png)   
![](https://github.com/sii2017/image/blob/master/%E6%97%8B%E8%BD%AC3.png)   
![](https://github.com/sii2017/image/blob/master/%E6%97%8B%E8%BD%AC4.png)   
![](https://github.com/sii2017/image/blob/master/%E6%97%8B%E8%BD%AC5.png)    
![](https://github.com/sii2017/image/blob/master/%E6%97%8B%E8%BD%AC6.png)    
插入情况二、左节点插入：   
![](https://github.com/sii2017/image/blob/master/%E6%97%8B%E8%BD%AC7.png)   
![](https://github.com/sii2017/image/blob/master/%E6%97%8B%E8%BD%AC8.png)   
![](https://github.com/sii2017/image/blob/master/%E6%97%8B%E8%BD%AC9.png)   
![](https://github.com/sii2017/image/blob/master/%E6%97%8B%E8%BD%AC10.png)   
![](https://github.com/sii2017/image/blob/master/%E6%97%8B%E8%BD%AC11.png)   
![](https://github.com/sii2017/image/blob/master/%E6%97%8B%E8%BD%AC12.png)    
插入情况三、根节点左旋转：   
![](https://github.com/sii2017/image/blob/master/%E6%97%8B%E8%BD%AC13.png)    
![](https://github.com/sii2017/image/blob/master/%E6%97%8B%E8%BD%AC14.png)   
![](https://github.com/sii2017/image/blob/master/%E6%97%8B%E8%BD%AC15.png)    
![](https://github.com/sii2017/image/blob/master/%E6%97%8B%E8%BD%AC16.png)   
从上面的示例可以看出：    
1.红黑树非移动情况下父节点与节点之间不会出现相同的颜色(比如都是红色，违反性质)；   
2.红黑树非移动情况下根节点为黑色；    
3.红黑树旋转的过程中会出现节点断开的情况，旋转完成恢复为新的树结构；     
4.红黑树结构适合随机访问，对于顺序访问采用链表结构效率会更高效。  
### 添加元素
**第一步: 将红黑树当作一颗二叉查找树，将节点插入。**   
红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。   
此外，无论是左旋还是右旋，若旋转之前这棵树是二叉查找树，旋转之后它一定还是二叉查找树。这也就意味着，任何的旋转和重新着色操作，都不会改变它仍然是一颗二叉查找树的事实。    
**第二步：将插入的节点着色为"红色"。**    
为什么着色成红色，而不是黑色呢？我们先重新温习一下红黑树的特性：     
> (1) 每个节点或者是黑色，或者是红色。   
> (2) 根节点是黑色。  
> (3) 每个叶子节点是黑色。 [注意：这里叶子节点，是指为空的叶子节点！]     
> (4) 如果一个节点是红色的，则它的子节点必须是黑色的。    
> (5) 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。    
   
将插入的节点着色为红色，不会违背"特性(5)"！少违背一条特性，就意味着我们需要处理的情况越少。接下来，就要努力的让这棵树满足其它性质即可；满足了的话，它就又是一颗红黑树了。     
**第三步: 通过一系列的旋转或着色等操作，使之重新成为一颗红黑树。**     
第二步中，将插入节点着色为"红色"之后，不会违背"特性(5)"。那它到底会违背哪些特性呢？   
对于"特性(1)"，显然不会违背了。因为我们已经将它涂成红色了。   
对于"特性(2)"，显然也不会违背。在第一步中，我们是将红黑树当作二叉查找树，然后执行的插入操作。而根据二叉查找数的特点，插入操作不会改变根节点。所以，根节点仍然是黑色。   
对于"特性(3)"，显然不会违背了。这里的叶子节点是指的空叶子节点，插入非空节点并不会对它们造成影响。   
对于"特性(4)"，是有可能违背的！    
那接下来，想办法使之"满足特性(4)"，就可以将树重新构造成红黑树了。    
**根据被插入节点的父节点的情况，可以将"当节点z被着色为红色节点，并插入二叉树"划分为三种情况来处理。**    
1 情况说明：被插入的节点是根节点。   
处理方法：直接把此节点涂为黑色。   
2 情况说明：被插入的节点的父节点是黑色。   
处理方法：什么也不需要做。节点被插入后，仍然是红黑树。    
3 情况说明：被插入的节点的父节点是红色。    
处理方法：那么，该情况与红黑树的“特性(5)”相冲突。这种情况下，被插入节点是一定存在非空祖父节点的；进一步的讲，被插入节点也一定存在叔叔节点(即使叔叔节点为空，我们也视之为存在，空节点本身就是黑色节点)。理解这点之后，我们依据"叔叔节点的情况"，**将这种情况进一步划分为3种情况(Case)**。     
![](https://github.com/sii2017/image/blob/master/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%A2%9E%E5%8A%A0%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%89%E7%A7%8D%E6%83%85%E5%86%B5.jpg)   
上面三种情况(Case)处理问题的核心思路都是：将红色的节点移到根节点；然后，将根节点设为黑色。    
### 删除元素  
将红黑树内的某一个节点删除。需要执行的操作依次是：首先，将红黑树当作一颗二叉查找树，将该节点从二叉查找树中删除；然后，通过"旋转和重新着色"等一系列来修正该树，使之重新成为一棵红黑树。如下：    
**第一步：将红黑树当作一颗二叉查找树，将节点删除。**     
这和"删除常规二叉查找树中删除节点的方法是一样的"。分3种情况：
1 被删除节点没有儿子节点。那么，直接将该节点删除就OK了。   
2 被删除节点只有一个儿子节点。那么直接删除该节点，并用该节点的唯一子节点顶替它的位置。    
3 被删除节点有两个儿子。那么，先找出它的后继节点；然后把“它的后继节点的内容”复制给“该节点的内容”；之后，删除“它的后继节点”。在这里，后继节点相当于替身，在将后继节点的内容复制给"被删除节点"之后，再将后继节点删除。这样就巧妙的将问题转换为"删除后继节点"的情况了，下面就考虑后继节点。 在"被删除节点"有两个非空子节点的情况下，它的后继节点不可能是双子非空。既然"的后继节点"不可能双子都非空，就意味着"该节点的后继节点"要么没有儿子，要么只有一个儿子。若没有儿子，则按"情况1"进行处理；若只有一个儿子，则按"情况2"进行处理。    
**第二步：通过"旋转和重新着色"等一系列来修正该树，使之重新成为一棵红黑树。**    
因为"第一步"中删除节点之后，可能会违背红黑树的特性。所以需要通过"旋转和重新着色"来修正该树，使之重新成为一棵红黑树。    