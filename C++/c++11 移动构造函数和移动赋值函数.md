## 移动构造函数和移动赋值函数
c++11新特性，移动构造函数和移动赋值函数。   
这两个函数通过c++11新加入的右值引用机制，节省了开辟空间的时间。    
先看一段一般情况下的代码：    
```c
#include <iostream>     
using namespace std;  

class A  
{  
public:  
	A(int i)  
	{  
		p = new int();  
		*p = i;   
		cout << "构造函数" << endl;  
	}   
	//拷贝构造函数  
	A(const A& a)  
	{  
		p = new int();  
		*p = *a.p;   
		cout << "拷贝构造函数" << endl;  
	}   
	//析构函数  
	~A()  
	{   
		delete[] p;   
		cout << "析构函数" << endl;  
	}    
private:    
	int* p;  
};    

//a作为参数传进来会调用一次拷贝构造函数拷贝一份临时变量，作为返回值传出去会再调用一次拷贝构造函数拷贝一份临时变量   
A test(A a)   
{  
	return a;  
}   

int main()  
{  
	A a(6);   
	A b(test(a));  
   
	getchar();  
	return 0;  
}   
```
以上代码输出结果为：构造函数，拷贝构造函数，拷贝构造函数，析构函数。   
其中我们可以看到，拷贝构造函数调用了两次，都是与函数test有关。a作为参数传进来会调用一次拷贝构造函数拷贝一份临时变量，作为返回值传出去会再调用一次拷贝构造函数拷贝一份临时变量。   
由于拷贝构造函数使用了深拷贝的方式，因此每一次调用拷贝构造函数都会申请内存，这是一笔不小的开销。然而这两笔不小的开销仅仅只是为了两次传参，并且使用后临时变量就会销毁。   
显然这种开销并不值得，因此c++11的新特性尝试着解决这个问题来提高效率。   
### 移动构造函数
如果第二个对象是在复制或赋值结束后被销毁的临时对象，则调用移动构造函数和移动赋值运算符，这样的好处是避免深度复制，提高效率。   
以下我们对代码进行改进，增加了移动构造函数。   
```c
#include <iostream>     
using namespace std;  
 
class A  
{   
public:  
	A(int i)   
	{  
		p = new int();   
		*p = i;  
		cout << "构造函数" << endl;   
	}   
	//拷贝构造函数  
	A(const A& a)   
	{  
		p = new int();   
		*p = *a.p;   
		cout << "拷贝构造函数" << endl;   
	}  
	//移动构造函数   
	A(A&& a)   
	{   
		p = a.p;   
		a.p = nullptr;   
		cout << "移动构造函数" << endl;  
	}    
	//析构函数  
	~A()   
	{   
		delete[] p;   
		cout << "析构函数" << endl;   
	}   
private:  
	int* p;   
};     

A test(A a)   
{  
	return a;   
}   

int main()   
{   
	A a(6);  
	A b(test(a));	//情况b   
	A c(test(std::move(a)));	//情况c  
  
	getchar();   
	return 0;    
}   
```    
移动构造函数的目的是避免无意义的深拷贝，通常我们将新构建的类的指针指向即将消亡的类的指针，同时原本即将消亡类的指针指向空。这样，即将消亡类的指针指向着空并正常消亡，且新构建的类也不用再重新申请内存。     
以上代码分为情况b和情况c。
情况b中的输出结果是，构造函数，拷贝构造函数，移动构造函数，析构函数。   
test的传参进函数的过程，仍然是调用的拷贝构造函数，因为移动构造函数针对右值，而a是左值。   
test的返回值是一个临时变量，也成为将亡值，是右值的一种，不可寻址，因此它调用了A类型中的移动构造函数。   
情况c中，我们通过std::move函数将a强行转换成了右值，因此其输出为：构造函数，移动构造函数，移动构造函数，析构函数。   
需要注意的是，当a被强制转换成了右值，那么a就不再可以被使用了，它的值是undefined的。   
> 关于为什么a不能再被使用。  
> 显然根据代码，c的p指针会指向a的p指针指向的地址，同时a的p指针指向了nullptr。因此a的p指针已经无效。a相当于已经不存在了。   
   
### 移动赋值运算符函数
移动赋值运算符函数与移动拷贝函数原理相同，但是在处理右值的时候减少深拷贝的次数，通过移动指针老减少消耗提高效率。  
直接给出代码：  
```c
#include <iostream>      
using namespace std;  

class A  
{  
public:  
	A(int i)  
	{   
		p = new int();  
		*p = i;   
		cout << "构造函数" << endl;  
	}  
	//拷贝构造函数  
	A(const A& a)  
	{   
		p = new int();   
		*p = *a.p;   
		cout << "拷贝构造函数" << endl;  
	}   
	//移动构造函数   
	A(A&& a)  
	{   
		p = a.p;  
		a.p = nullptr;   
		cout << "移动构造函数" << endl;  
	}    
	//赋值运算符函数   
	A& operator=(const A& a)  
	{   
		p = new int();   
		*p = *a.p;   
		cout << "赋值运算符函数" << endl;   
		return *this;   
	}  
	//移动赋值运算符函数   
	A& operator=(const A&& a)   
	{   
		p = a.p;   
		p = nullptr;    
		cout << "移动赋值运算符函数" << endl;   
		return *this;   
	}   
	//析构函数  
	~A()   
	{   
		delete[] p;   
		cout << "析构函数" << endl;   
	}  
private:   
	int* p;  
};   

A test(A a)  
{   
	return a;  
}   

int main()  
{   
	A a(6);  
	A b(1);  
	b = test(std::move(a));   
 
	getchar();  
	return 0;   
}  
```   
这个代码的输出是：构造函数，构造函数，移动构造函数，移动构造函数，析构函数，移动赋值运算符函数，析构函数。  
test的参数传入和返回值传回都是调用了移动构造函数，给b的赋值也调用了移动赋值运算符函数。   
### 小结
1 移动构造函数和移动赋值运算符函数通过转移指针，减少了申请内存的次数，提高了运行效率。   
2 主要针对一些不值得进行深拷贝的临时对象，如将亡值/右值/临时变量。   
3 如果使用move函数将一个对象变成了右值，该对象的生命周期不会发生改变。但是由于它的值已经被转移了，因此不要再使用该对象，或者给该对象赋新值。  
4 如果没有显示的提供移动构造函数和移动赋值函数，编译器会提供默认的移动构造函数和默认移动赋值函数。（如同默认构造函数、默认复制构造函数、默认赋值运算符和默认析构函数一样） 