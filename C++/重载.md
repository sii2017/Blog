## 重载 overload
### 重载函数
重载函数是函数的一种特殊情况，为方便使用，C++允许在同一范围中声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同，也就是说用同一个运算符完成不同的运算功能。重载函数常用来实现功能类似而所处理的数据类型不同的问题。但是重载函数的返回值类型可以不同。    
即定义几个名字相同，且参数不同的函数，调用的时候通过不同的参数，由编译器来决定调用对应的函数。   
**两个重载函数必须在下列一个或两个方面有所区别：**   
1 函数有不同数量的参数。    
2 函数有不同的参数类型。（这种情况有可以通过模板来实现）   
直接上例子：  
```c
#include <iostream>  
#include <vector>   
using namespace std;   

//同一个名字的函数，重载了三个版本，分别针对2个参数的int类型，doble类型以及一个参数的vector结构。   
int add(int a, int b)  
{   
	return a + b;  
}    

double add(double a, double b)  
{  
	return a + b;   
}   

int add(vector<int> vec)   
{  
	int que = 0;  
	int num = vec.size();   
	for (int i = 0; i < num; i++)   
	{ 
		que += vec[i];   
	}   
	return que;   
}   
int main()    
{  
	cout << add(1, 2) << endl;//调用了第一种重载函数     
	cout << add(1.4, 1.5) << endl;//调用了第二种重载函数    
	vector<int> abc = { 1,2,3,4,5 };//调用了第三种重载函数     
	cout << add(abc) << endl;   
	getchar();  
	return 0;  
}  
```   
注意：   
1 如果传入的参数与所有的重载函数都不符，编译器找不到可以匹配的会报错。    
2 是否重载是以参数为特征标记的，如果返回值不同但是参数相同，则不构成重载。   
3 相同类型与其引用被认为是相同的特征标记，不会引发重载。   
4 const对于普通的参数是无效的，不能引发重载；但是对于指针和引用是有效的，可以引发重载。   
### 重载操作符   
重载操作符与重载函数相类似。
重载原先的含义是，使同名的函数在针对不同的场景（即不同类型的参数，不同数量的参数）进行多样化的使用。这可以称为是扩展函数的功能。   
而在操作符重载中，我们所谓的“扩展其功能”可能只是“补全操作符的功能”。为什么这样说呢？   
因为对于内置类型如int,double等，我们可以正常使用等于、大于、小于这些操作符的功能。但是如果是我们自定义的类的实例，则无法正常使用这些操作符。这种情况下我们对操作符进行重载，来使之既符合原先的含义，又能在我们的实例间正常使用。       
重载操作符后，对于原来的类型（如int，double等），操作符仍然正常工作。但是对于我们自定义类的实例，操作符能按照我们的定义进行工作。   

**注意事项：**   
1 重载不能改变操作符的基本功能（脱离实例情况下），以及该操作符的优先级顺序。    
2 重载**不应**改变操作符的本来含义。     
3 只能对已有的操作符进行重载，不能重载新符号。   
4 操作符重载只对类有效。   
5 以下操作符不能被重载：   
指向成员的指针星号  
::作用域解析符     
?:问号条件运算符    
sizeof操作数的字节数    
**不同条件下操作符重载函数参数的限定**    
1 非成员函数：   
单目运算符：参数表中只有一个参数；   
双目运算符：参数表中只有两个参数；   
2 成员函数：     
单目运算符：参数表中没有参数；   
双目运算符：参数表中只有一个参数。     
**声明及定义一个操作符重载函数**   
1 操作符重载函数为类成员函数，代表左操作数的参数已经被隐式指定为了自己类实例。    
```c
//以重载==为例   
//person.h   
class person   
{    
private:    
	int age;    
public:   
	person(int a)   
	{    
		this->age= a;   
	}     
	//operator加上符号为函数名。   
	//如果是单目运算符则不需要参数，比如自增自减，因为参数就是实例本身的成员   
	//如果是双目运算符则需要一个参数，比如加号减号，加上本身自己就是一个参数，对自己及传进来的参数进行处理。    
	bool operator==(const person& ps) const   
	{  
		//函数内定义了对该操作符的具体处理方式，其实就是比较两个实例里的成员的大小。这里必须手动定义，因为编译器无法自动替我们进行比较。    
		return this->age== ps.age;   
	}    
};   
   
//main.cpp   
#include "person.h"   
using namespace std;   
int main()   
{   
	person p1(10);   
	person p2(20);   
	if(p1==p2)	//由于是person类的2个实例进行比较，这里调用了操作符重载函数。      
		cout << "the age is equal" << endl;    
	return 0;    
}      
```    
2 操作符重载函数为非类成员函数（全局函数），代表左操作数的参数必须被显示指定。   
```c
#include <iostream>      
class Student   
{   
public:    
	Student(int a):age(a){}   
	int age;    
};    

class Teacher   
{   
public:    
	Teacher(int a):age(a){}   
	int age;   
};    

bool operator==(const Student& age1, const Teacher& age2)   
{    
	//这里由于age是两个类的公有成员，因此全局函数可以访问，而如果是私有成员，则需要在类内声明这个函数为友元函数帮助访问   
	return age1.age == age2.age;   
}    
   
int main()   
{   
	Student st(20);   
	Teacher tea(20);   
	if (st == tea)    
		std::cout << "equal" << std::endl;  
	else    
		std::cout << "not equal" << std::endl;   
	getchar();   
	return 0;   
}   
```     
3 操作符重载中针对自增自减的情况   
自增运算符“++”和自减运算符“--”分别包含两个版本。即运算符前置形式(如 ++x)和运算符后置形式(如 x++)，这两者进行的操作是不一样的。因此，当我们在对这两个运算符进行重载时，就必须区分前置和后置形式。C++根据参数的个数来区分前置和后置形式。     
如果按照通常的方法来重载 ++ 运算符(即作为成员函数重载时不带参数，或者作为非成员函数重载时带有一个参数)，那么重载的是前置版本。要对后置形式进行重载，即 x++ 或 x--，就必须为重载函数再增加一个 int 类型的参数。**该参数仅仅用来告诉编译器这是一个运算符后置形式，在实际调用时不需要给出实际的参数值。**    
```c
#include <iostream>   
using namespace std;  
class A    
{   
public:    
	A(int a) :num(a) {}   
	A operator++()	//无参数则前置自增   
	{   
		num++;    
		return *this;//返回的不是数字而是自己的实例   
	}   

	A operator++(int)	//一个形参int则代表后置自增   
	{    
		A temp = *this;   
		num++;     
		return temp;//后置++要返回原数据再自增，所以返回之前保存下来的copy  
	}   
	int Getvalue()   
	{    
		return num;   
	}   
private:  
	int num;  
};   

int main()   
{   
	A a1(10);   
	cout << a1.Getvalue() << endl;  
	a1.operator++();//实际上也能这么调用，但是不常用      
	cout << a1.Getvalue() << endl;   
	a1++;//后置加加并不需要加上形参int，形参只是为了个编译器区分这是后置自增。     
	cout << a1.Getvalue() << endl;  
	++a1;    
	cout << a1.Getvalue() << endl;    
	getchar();   
	return 0;   
}    
```   
4 操作符重载中重载数据流的情况   
在重载输出输入运算符的时候，只能采用全局函数的方式（因为我们不能在ostream和istream类中编写成员函数），这里才是友元函数真正的应用场景。   
对于输出运算符，主要负责打印对象的内容而非控制格式，输出运算符不应该打印换行符（即endl）。   
对于输入运算符，必须处理可能失败的情况（通常处理输入失败为默认构造函数的形式），而输出运算符不需要。    
```c
#include <iostream>    
using namespace std;   
class Test   
{   
public:    
	Test(int a1 = 0, int b1 = 0):a(a1), b(b1) {}    
	//通过友元的形式使外部函数可以访问类内的所有成员     
	friend ostream& operator<<(ostream& out, Test& obj);   
	friend istream& operator>>(istream& in, Test& obj);   
private:   
	int a;   
	int b;   
};   

//由于输入输出流符号是属于ostream和istream类的，并且使用这两个操作符会使用到这两个类，但是我们无法在这两个类内重载符号，所以采用全局函数的方式    
ostream& operator<<(ostream& out, Test& obj)   
{   
	out << obj.a << " " << obj.b;   
	return out;   
}   
istream& operator>>(istream& in, Test& obj)    
{  
	in >> obj.a >> obj.b;    
	if (!in)   
	{   
		obj = Test();   
	}   
	return in;   
}     

int main()   
{  
	Test t1(1, 2);   
	cout << t1 << endl;   
	cout << "重新输入两个int值" << endl;   
	cin >> t1;  
	cout << t1 << endl;    
	getchar();   
	return 0;  
}   
```      
4.1 为什么输入输出操作符不能重载在调用的类内作为成员函数。   
首先输入输出操作符<<和>>不能在类ostream和istream中进行重载，因为这两个类继承了标准库中的流类，而这两个符号没有被声明为虚函数，所以子类ostream和istream无法对其进行覆盖。   
其次大部分的标准库实现中，对于ostream和istream类体系采用了构造函数保护继承的方式，即使以继承的方式来扩展流类，也会在对象实例化的时候遭遇阻碍。    
我们可以在使用的类中重载输入输出操作符，而不使用友元全局的形式。但是我们并不常这么做，因为这样做会与我们日常使用习惯不符，如下：  
```c   
Clsss T   
{    
	//重载<<和>>符号；     
}      
//如果重载成功的话进行输出   
T t;   
t<< cout;   
//而不是cout<<t;   
```   
所以我们一般不这么做。   