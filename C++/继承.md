## 继承
继承是面向对象程序设计中使代码可以复用的最重要的手段。  
它允许程序员在原有类特性的基础上进行扩展，增加功能。这样产生的新类，就叫做派生类/子类。而被继承的类被称为基类/父类。    
继承呈现了面向对象程序设计的层次结构,体现了由简单到复杂的认知过程。    
### 三种访问限制的继承方式
![](https://github.com/sii2017/image/blob/master/%E7%BB%A7%E6%89%BF.png)   
公有继承将原分不动的从基类继承所有的内容。   
保护继承，将基类的公有部分继承为保护，其余不动。   
私有继承，将基类的所有内容都继承为私有。    
### 继承关系中的构造函数和析构函数
先看代码。  
```c
#include <iostream>  
using namespace std;   
   
class T   
{   
public:   
	T(int i = 1)    
	{   
		cout << "T()" << endl;   
	}   

	~T()   
	{   
		cout << "~T()" << endl;    
	}   
};   
   
class A   
{  
public:    
	A()  
	{   
		cout << "A()" << endl;   
	}   
   
	~A()   
	{  
		cout << "~A()" << endl;    
	}    

public:   
	int pub;  
protected:   
	int pro;  
private:    
	int pri;   
};    

class B : public A   
{    
public:   
	B()  
	{    
		cout << "B()" << endl;   
	}   

	~B()   
	{   
		cout << "~B()" << endl;   
	}   
public:   
	T t;   
};   

int main()   
{   
	B b;   
	getchar();  
	return 0;   
}    
```   
当子类B类初始化时，会先调用基类A类的构造函数（尽管没有初始化A类的对象）。（如果B类中有其他类T类的成员对象），然后调用T类的构造函数，最后才调用B类自己的构造函数。   
析构函数则反之。   
![](https://github.com/sii2017/image/blob/master/%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E9%A1%BA%E5%BA%8F.png)  
### 继承体系中的作用域
1 基类类和派生类有着不同的作用域，但是实际上子类中由基类继承的成员变量为同一个内存空间（他们可以用不同的作用域来进行访问）。      
2 同名隐藏：子类和父类中有同名成员时,子类成员将屏蔽父类对成员的直接访问。(在子类成员函数中,可以使用 基类::基类成员 来访问父类成员)   
3 在实际中在继承体系里面最好不要定义同名的成员   
```
#include <iostream>   
using namespace std;   
   
class A  
{    
public:   
	A()   
	{   
		cout << "A()" << endl;   
	}  

	~A()    
	{   
		cout << "~A()" << endl;   
	}   
	void show()   
	{    
		cout << pub << endl;    
	}  
public:    
	int pub;   
};   

class B : public A   
{   
public:  
	B()   
	{   
		cout << "B()" << endl;   
	}    

	~B()   
	{   
		cout << "~B()" << endl;   
	}   
};   

int main()    
{   
	B b;   
	//通过对象b进行赋值，然后调用对象b的显示函数，显示结果为45，这毋庸置疑。    
	b.pub = 45;	   
	b.show();  
	//通过对象b给作用域A的pub赋值，但是用对象b的显示函数，显示结果为100。显然作用域A的pub就是对象b的pub。   
	b.A::pub = 100;   
	b.show();    
	//通过给对象b的pub进行赋值，但是使用对象b作用域A的显示函数，显示结果为10086，可以断定尽管我们使用作用域，但是实例中的函数或成员变量只有一个。      
	b.pub = 10086;   
	b.A::show();   
	getchar();   
	return 0;    
}   
```   
### 继承与转换 赋值兼容规则（前提：public继承）
1 子类对象可以赋值给父类对象。   
2 父类对象不能赋值给子类对象。  
3 父类的指针/引用可以指向子类对象。    
4 子类的指针/引用不能指向父类对象(但可以通过强制类型转换完成)。     
### 友元与继承
友元关系不能继承,也就是说基类友元不能访问子类私有和保护成员。   
### 单继承与多继承
一个子类只有一个父类时称这个继承关系为单继承。   
![](https://github.com/sii2017/image/blob/master/%E5%8D%95%E7%BB%A7%E6%89%BF.jpg)   
一个子类有两个或以上直接父类时称这个继承关系为多继承。    
![](https://github.com/sii2017/image/blob/master/%E5%A4%9A%E7%BB%A7%E6%89%BF.jpg)   
### 菱形继承
菱形继承则是，先由一个基类派生两个类，最后由一个类同时继承这两个派生类。因此继承派生关系图如菱形一般。   
![](https://github.com/sii2017/image/blob/master/%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF.jpg)   
