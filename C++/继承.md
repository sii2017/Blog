# 继承
继承是面向对象程序设计中使代码可以复用的最重要的手段。  
它允许程序员在原有类特性的基础上进行扩展，增加功能。这样产生的新类，就叫做派生类/子类。而被继承的类被称为基类/父类。    
继承呈现了面向对象程序设计的层次结构,体现了由简单到复杂的认知过程。    
## 三种访问限制的继承方式
![](https://github.com/sii2017/image/blob/master/%E7%BB%A7%E6%89%BF.jpg)    
公有继承：派生类可以访问基类的公有成员变量，成员函数，不能访问基类的私有内容，但是可以通过基类的公有的函数访问基类的私有内容。   
保护继承，将基类的公有部分继承为保护，其余不动。   
私有继承，将基类的所有内容都继承为私有。    
### 公有继承
基类的公有成员，变成派生类的公有成员，可以在派生类内部以及通过派生类实例在外部调用；         
基类的保护成员，变成派生类的保护成员，可以在派生类内部调用，但是不能通过派生类实从外部调用；    
基类的私有成员，仍然是基类的私有成员，不能通过派生类调用，但是派生类可以通过基类的公有或保护接口（公有/保护函数）调用基类的私有成员。   
公有继承是使用的比较多的一种继承。   
### 私有继承
基类的公有成员，变成派生类的私有成员，只能在派生类内部调用，不能通过派生类实例从外部调用；   
基类的保护成员，变成派生类的私有成员，与上相同，只能在派生类内部调用，不能通过派生类实例从外部调用；   
基类的私有成员，仍然是基类的私有成员，不能通过派生类调用，但是派生类可以通过基类的公有或保护接口（公有/保护函数）调用基类的私有成员。   
### 保护继承     
基类的公有成员，变成派生类的保护成员，只能在派生类内调用，而不能通过派生类实例从外部调用；   
基类的保护成员，变成派生类的保护成员，与上面相同，只能在派生类内调用，而不能通过派生类实例从外部调用；   
基类的私有成员，仍然是基类的私有成员，不能通过派生类调用，但是派生类可以通过基类的公有或保护接口（公有/保护函数）调用基类的私有成员。   
### 三种继承小结
1 基类的私有成员总是无法被派生类直接访问的，只能通过接口访问。   
2 基类的公有成员随着继承方式的不同而改变，公有继承则还是公有，保护继承则变成保护，私有继承则变成私有。   
3 基类的保护成员除了私有继承会变成派生类的私有成员，其它时候他总是保护成员。   
4 在继承关系中，对同名函数的处理，是隐藏基类的同名函数，而不是一般的“根据参数特征标生成不同的重载函数”的处理。同名的成员变量同理。   
5 由于私**有继承和保护继承**会把基类的公有方法继承成为私有和保护的，则该方法无法作为公共接口被实例从外部调用，这时候我们可以手动使用using重新定义访问权限：  
```c
class T: private std::valarray<double>   
{   
public:    
	using std::valarray<double>::min;    
};    
```   
上面的using声明使得valarray<double>::min()变为可用，就像是他们是T的公有方法一样。   
## 继承关系中的构造函数和析构函数
先看代码。  
```c
#include <iostream>  
using namespace std;   
   
class T   
{   
public:   
	T(int i = 1)    
	{   
		cout << "T()" << endl;   
	}   

	~T()   
	{   
		cout << "~T()" << endl;    
	}   
};   
   
class A   
{  
public:    
	A()  
	{   
		cout << "A()" << endl;   
	}   
   
	~A()   
	{  
		cout << "~A()" << endl;    
	}    

public:   
	int pub;  
protected:   
	int pro;  
private:    
	int pri;   
};    

class B : public A   
{    
public:   
	B()  
	{    
		cout << "B()" << endl;   
	}   

	~B()   
	{   
		cout << "~B()" << endl;   
	}   
public:   
	T t;   
};   

int main()   
{   
	B b;   
	getchar();  
	return 0;   
}    
```   
当子类B类初始化时，会先调用基类A类的构造函数（尽管没有初始化A类的对象）。（如果B类中有其他类T类的成员对象），然后调用T类的构造函数，最后才调用B类自己的构造函数。   
析构函数则反之。   
![](https://github.com/sii2017/image/blob/master/%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E9%A1%BA%E5%BA%8F.png)  
## 继承体系中的作用域
1 基类类和派生类有着不同的作用域，但是实际上子类中由基类继承的成员变量为同一个内存空间（他们可以用不同的作用域来进行访问）。      
2 同名隐藏：子类和父类中有同名成员时,子类成员将屏蔽父类对成员的直接访问。(在子类成员函数中,可以使用 基类::基类成员 来访问父类成员)   
3 在实际中在继承体系里面最好不要定义同名的成员   
```
#include <iostream>   
using namespace std;   
   
class A  
{    
public:   
	A()   
	{   
		cout << "A()" << endl;   
	}  

	~A()    
	{   
		cout << "~A()" << endl;   
	}   
	void show()   
	{    
		cout << pub << endl;    
	}  
public:    
	int pub;   
};   

class B : public A   
{   
public:  
	B()   
	{   
		cout << "B()" << endl;   
	}    

	~B()   
	{   
		cout << "~B()" << endl;   
	}   
};   

int main()    
{   
	B b;   
	//通过对象b进行赋值，然后调用对象b的显示函数，显示结果为45，这毋庸置疑。    
	b.pub = 45;	   
	b.show();  
	//通过对象b给作用域A的pub赋值，但是用对象b的显示函数，显示结果为100。显然作用域A的pub就是对象b的pub。   
	b.A::pub = 100;   
	b.show();    
	//通过给对象b的pub进行赋值，但是使用对象b作用域A的显示函数，显示结果为10086，可以断定尽管我们使用作用域，但是实例中的函数或成员变量只有一个。      
	b.pub = 10086;   
	b.A::show();   
	getchar();   
	return 0;    
}   
```   
## 继承与转换 赋值兼容规则（前提：public继承）
1 子类对象可以赋值给父类对象。   
2 父类对象不能赋值给子类对象。  
3 父类的指针/引用可以指向子类对象。    
4 子类的指针/引用不能指向父类对象(但可以通过强制类型转换完成)。   
> 子类继承于父类，它含有父类的部分，又做了扩充。如果子类对象赋值给父类变量，则使用该变量只能访问子类的父类部分。（因为子类含有父类的部分，所以不会有问题）    
> 但是，如果反过来，这个子类变量如果去访问它的扩充成员变量，就会访问不到，因为原变量不包含该部分，会内存越界。     
## 友元与继承
友元关系不能继承,也就是说基类友元不能访问子类私有和保护成员。   
## 单继承与多继承
一个子类只有一个父类时称这个继承关系为单继承。   
![](https://github.com/sii2017/image/blob/master/%E5%8D%95%E7%BB%A7%E6%89%BF.jpg)   
一个子类有两个或以上直接父类时称这个继承关系为多继承。    
![](https://github.com/sii2017/image/blob/master/%E5%A4%9A%E7%BB%A7%E6%89%BF.jpg)   
## 菱形继承
菱形继承也称为多继承或钻石继承。   
先由一个基类派生两个类，最后由一个类同时继承这两个派生类。因此继承派生关系图如菱形一般。   
![](https://github.com/sii2017/image/blob/master/%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF.jpg)   
一般不建议使用菱形继承，由于其比较复杂，且但凡菱形继承需要的功能都可以通过单继承获得。   
并且菱形继承会产生二义性问题。   
```c
#include <iostream>    
class A   
{    
	int num;   
}   

class B: public A   
{    
	//继承了class A的num   
}   

class C: public A   
{   
	//继承了class A的num
}   

class D: public B, public C    
{   
	//继承了class B继承的class A的num以及class C继承的class A的num，两个相同的num发生了冲突。   
	//编译器不知道自己继承的到底是class B继承的num还是class C继承的num    
}    
```   
这个问题又**虚继承**解决。   
## 虚继承   
虚继承和虚函数是完全无相关的两个概念。
虚继承是解决C++多重继承问题的一种手段，从不同途径继承来的同一基类，会在子类中存在多份拷贝。   
> 即虚继承不管父类派生出多少个子类在内存总只存在一套数据，但是一般继承会存在与派生类个数对应的N个数据（N为派生类个数）。   
  
这将存在两个问题：其一，浪费存储空间；第二，存在二义性问题，通常可以将派生类对象的地址赋值给基类对象，实现的具体方式是，将基类指针指向继承类（继承类有基类的拷贝）中的基类对象的地址，但是多重继承可能存在一个基类的多份拷贝，这就出现了二义性。   
我们可以将普通继承变为“虚继承”来解决这个问题。   
```c
#include <iostream>   

class A   
{   
private:    
	int num;  
}   
   
class Aa: virtual public A    
{   
}   

class Ab: virtual public A   
{   
}   

class AaAb: public Aa, public Ab   
{    
}  

int main()    
{   
	//如果是普通继承，在aaab中会有两份class A派生的num，但是在虚继承的情况下，只会有一份    
	AaAb aaab;  
	return 0;   
}   
```   
为什么虚继承与普通继承有不同呢？    
在普通继承中，A实实在在的生成了两个实例，并分别派生给了Aa和Ab，占用了两份内存。    
在虚继承中，Aa和Ab并不会有两份A的实例，而是分别有一个指向类A的虚基类指针列表vbptr（virtual base table pointer）（虚基表指针）。其中记录的是从Aa和Ab的vbtable的首地址（vbptr）到A的元素之间的偏移量，通过指针来达到共享的目的。（详细内容可参考虚表相关内容）。   
一般在日常使用中，虚继承使用的比较少，且仅在多继承的情况下解决二义性有效。如果只是一般的继承，则多继承会占用更多的内存（虚表会占用额外的内存）。    