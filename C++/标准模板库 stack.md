## 标准模板库 stack 堆栈
stack是标准模板库的一种**容器适配器**。（与queue类似）   
是的，它不只是一种容器，而是封装了一个类作为他的特定容器，提供了一组成员函数去访问该容器的元素。   
在默认的情况下stack使用deque队列作为自己的特定容器，当然我们也可以使用其它的容器如vector，list等。   
stack的访问顺序，以“后进先出（last-in first-out)”为特点。（相似的，queue的特点是先进先出（first-in first-out））     
当我们需要保存一些内容，并且希望当我们随后取出他们的时候，取出的是最后放进去的元素，那么我们可以使用stack容器。   
### 头文件支持 
```c   
#include <stack>   
``` 
### 初始化   
```c
//使用默认容器的初始化，当没有制定容器参数的时候，默认使用deque作为特定容器。   
stack<int> st;	//创建一个空的栈  
	
stack<int> s1;
s1.push(1);
s1.push(2);
s1.push(3);
stack<int> s2(s1);	//通过s1初始化s2  

//使用特定容器的初始化   
stack<int, vector<int>> st;	//使用vector作为自己的特定容器  
stack<int, list<int>> st;	//使用list作为自己的特定容器   
```  
stack的初始化模式比较少。  
当没有制定容器参数的时候，默认使用deque作为特定容器。当我们使用其它容器作为特定容器的时候，该容器必须包含以下函数：   
empty();    
size();   
back();    
push\_back();    
pop\_back();       
在标准容器中，vector、deque和list都满足这些要求。   
### 添加元素
```
stack<int> st;  
st.push(10);   
st.push(12);	//直接将元素push到顶端    
st.emplace(100);	//直接将元素添加（构造）在顶端    
```  
emplace相关函数是c++11新推出的函数，emplace相关函数则是直接把元素传递给该元素的构造函数，在相关位置直接进行构造。因此emplace的效率是高于一般的插入元素的函数的。   
stack添加元素的函数也比较简单，它只能从顶部进行添加（也只能从顶部删除元素）。   
### 删除元素
```c  
st.pop();   
```   
弹出（删除）顶部的元素。并且stack也只能从顶部删除元素。   
不存在批量删除元素，只能一个一个删除。   
### 功能函数   
功能函数也比较少  
stack<int> st;  
st.empty();	//返回该容器是否为空   
st.size();	//返回容器大小  
st1.swap(st2);	//交换两个容器的元素  
st.top();	//返回顶元素  
以上就是仅有的几个功能元素。   
### 迭代器的使用及遍历  
不支持迭代器，也不支持遍历。   
如果非要遍历的话，只能一边弹出一边遍历了。   
```c
while (!st.empty())  
{   
	cout << st.top();  
	st.pop();  
}  
```  
### 总结   
可以看出stack的特点比较旗帜鲜明，它就是模拟我们栈的形式，以“后进先出”为主要目的，来达到模拟的效果。  
同时，他也不具有其它容器如vector和list，较为复杂的功能函数，既不支持迭代，也不支持遍历。  
因此当我们需要“后进先出”的容器的时候使用stack，但是在其它时候，stack就不是合适的选择了。   
不知道该用什么的时候就用vector，至少不要用stack。  