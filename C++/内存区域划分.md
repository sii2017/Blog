## 内存区域划分
不同的变量在内存中存放的位置不同，尽管在当前工作中不也许不需要太过深入了解内存中的区域划分，但是仍然是有益无害的。    
### 在c中的区域划分
1.栈——由编译器自动分配释放。    
2.堆——一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。   
3.全局区（静态区）——全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域（C++中已经不再这样划分）。程序结束释放。    
4.常量存储区，另外一个专门放常量的地方，程序结束释放。    
### 在c++中的区域划分
1.栈，就是那些由编译器在需要的时候分配，在不需要的时候自动清楚的变量的存储区函。里面的变量通常是局部变量、数参数等。   
2.堆，是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。    
3.自由存储区，是由malloc等分配的内存块，他和堆是十分相似的，用free来结束自己的生命的。    
4.全局/静态存储区，全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。    
5.常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改（当然，你要通过非正当手段也可以修改）    
### 例子
```c
char* pp= "123456";	//123456在常量区，pp在全局区   
int a = 0; //全局初始化区，c++中直接为全局区      
char *p1; //全局未初始化区，c++中直接为全局区    
int main()    
{    
	//函数内部及局部区域在声明的变量在栈上   
     int b; //栈    
     char s[] = "abc"; //栈     
     char *p2; //栈   
     char *p3 = "123456"; //123456在常量区，p3在栈上    
     static int c = 0; //全局（静态）初始化区    
     p1 = (char *)malloc(10); //分配得来得10字节的区域在堆区   
     p2 = (char *)malloc(20); //分配得来得20字节的区域在堆区    
     strcpy(p1, "123456");//123456放在常量区，p1仍然在堆上    
 }   
```
### 小结
(a)函数体中定义的变量通常是在栈上。   
(b)用malloc, calloc, realloc等分配内存的函数分配得到的就是在堆上。     
(c)在所有函数体外定义的是全局变量，在全局区域。   
(d)加了static修饰符后不管在哪里都存放在全局区（静态区）。      
(e)另外，函数中的"adgfdf"这样的字符串存放在常量区。    
(f)new所申请的内存区域在C++中称为自由存储区。藉由堆实现的自由存储，可以说new所申请的内存区域在堆上。    
### 堆（heap）与自由存储区（free store）的区别
> “malloc在堆上分配的内存块，使用free释放内存，而new所申请的内存则是在自由存储区上，使用delete来释放。”   

可是，自由存储区与堆是两块不同的内存区域吗？它们有可能相同吗？   
从技术上来说，堆（heap）是C语言和操作系统的术语。堆是操作系统所维护的一块特殊内存，它提供了动态分配的功能。当运行程序调用malloc()时就会从中分配，稍后调用free可把内存交还。   
而自由存储是C++中通过new和delete动态分配和释放对象的**抽象概念**，通过new来申请的内存区域可称为自由存储区。基本上，所有的C++编译器**默认使用堆**来实现自由存储，也即是缺省的全局运算符new和delete也许会按照malloc和free的方式来被实现，这时藉由new运算符分配的对象，说它在堆上也对，说它在自由存储区上也正确。    
但程序员也可以通过重载操作符，改用其他内存来实现自由存储，例如全局变量做的对象池，这时自由存储区就区别于堆了。    
> 堆是操作系统维护的一块内存，而自由存储是C++中通过new与delete动态分配和释放对象的抽象概念。堆与自由存储区并不等价。   
简单的概括，默认的（抽象概念）自由存储区域是在堆上，因此默认情况下new动态分配的内存区域就在堆上。但是如果new被重载了，改用其他内存来实现自由存储，那么自由存储的位置就不在堆上了。   
### 栈（stack）与堆（heap）的区别
**申请方式**     
栈（stack）:由系统自动分配。     
堆（heap）:需要程序员自己申请，并指明大小。   
```c
//在c中malloc函数如   
p1= (char*)malloc(10);     
//在C++中用new运算符    
p2= new char[10];    
//但是注意p1、p2本身是在栈中的。    
```   
**申请后系统的响应**    
栈（stack）：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。    
堆（heap）：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。   
对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。  
另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。    
**申请大小的限制**    
栈（stack）：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。即栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。     
堆（heap）：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。    
**申请效率的比较**       
栈（stack）：由系统自动分配，速度较快。但程序员是无法控制的。    
堆（heap）：由new/malloc分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便，灵活性好。    
另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是直接在进程的地址空间中保留一块内存，虽然用起来最不方便。但是速度快，也最灵活。    
**堆和栈中的存储内容**    
栈（stack）：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。    
当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。    
堆（heap）：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。    
**小结**    
堆和栈的区别可以用如下的比喻来看出：    
使用栈的好处是快捷，但是自由度小。    
使用堆就比较麻烦，但是自由度大。      