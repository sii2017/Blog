## 字节对齐
现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。  
而日常使用中，主要体现在类和结构体中。  
### 字节对齐规则
字节对齐主要有以下规则：  
1 对于类内的成员变量，编译器是按照顺序为其分配地址的。   
2 函数是不占用内存地址的。   
3 指向虚函数表的虚指针永远在最前面。   
4 **在给变量分配地址的时候，存在一个偏移值为：min(当前变量占用的大小，默认偏移量大小）。该变量的地址到起始位置的距离必须可以整除该偏移值。即：(成员的起始地址相对于结构的起始地址的偏移) % (成员的有效对齐) == 0**   
5 **默认偏移量可以由pragma pack(x)进行设置，x的合法值为1,2,4,8,16。没有设置默认偏移量则默认为类内最长的变量的长度。**     
6 **当所有变量都分配完后，总的长度必须可以整除默认偏移量大小，不然就分配依序分配额外的字节数，直到可以整除默认偏移量大小。即：(结构的总大小) % (结构的有效对齐) == 0**   
### 例子
```c
#include <iostream>  
using namespace std;   

class A  
{                
	int a;		//0123    
	char b;		//4                    
	short c;	//67 不能从5开始，min(2,4)，5%2!=0不符合，偏移到6，6%2=0符合               
};				//共8个子节，8%4=0，符合               
             
class B                     
{                           
	char a;		//0                          
	int b;		//4567 不能从1开始，min(4,4),1%4!=0,偏移到4，4%4=0符合                                     
	short c;	//89 min(2,4),8%2=0符合                 
};				//10%4!=0不符合，再偏移到12，12%4=0符合，共12个子节                 
                     
class C                
{                 
	short a;	//01                            
	char b;		//2 min(1,4),2%1=0符合               
	int c;		//4567 min(4,4),3%4!=0不符合，偏倚到4，4%4=0符合             
};				//共8个子节，8%4=0符合               
               
class father              
{                           
public:               
	virtual void function() {}	//函数本身不占空间，但是虚指针占4个字节                    
};                                   

class child: public father         
{					//首先继承的虚指针占4个子节 0123                
	char a;			//4 min(1,8),4%1=0符合                            
	double b;		//89101112131415 min(8,8),5%8!=0不符合，位移到8，8%8=0符合，double占8个子节                
	int c;			//16171819 min(4,8),16%4=0符合             
};					//当前共20个子节，但是20%8!=0不符合，再偏移到24符合，共24个子节                         

class D              
{            
	char a;			//0                  
	double b;		//89101112131415 1%8!=0不符合，8%8=0符合          
};					//总的长度为16，16%8=0符合                

# pragma pack(4)           
class E           
{             
	char a;		//0            
	double b;	//由于设置了偏移值为4，min(4,8),因此从4开始            
};				//总的长度为12，12%4=0符合             
             
int main()           
{                        
	cout << "A is " << sizeof(A) << endl;           
	cout << "B is " << sizeof(B) << endl;             
	cout << "C is " << sizeof(C) << endl;            
	cout << "father is " << sizeof(father) << endl;            
	cout << "child is " << sizeof(child) << endl;                    
	cout << "D is " << sizeof(D) << endl;             
	cout << "E is " << sizeof(E) << endl;                             
 	getchar();          
	return 0;           
}          
```           
### 关于pragma pack  
pragma pack(n)可以设置默认偏移量大小，合法值为1,2,4,8,16。没有设置的话，默认为类中最大的值的长度。   
pragma pack(push)将当前偏移量大小保存到栈中。   
pragma pack(pop)重新设置为保存的偏移量大小。   