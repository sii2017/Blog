## 重载函数 overload
重载函数是函数的一种特殊情况，为方便使用，C++允许在同一范围中声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同，也就是说用同一个运算符完成不同的运算功能。重载函数常用来实现功能类似而所处理的数据类型不同的问题。但是重载函数的返回值类型可以不同。    
即定义几个名字相同，且参数不同的函数，调用的时候通过不同的参数，由编译器来决定调用对应的函数。   
**两个重载函数必须在下列一个或两个方面有所区别：**   
1 函数有不同数量的参数。    
2 函数有不同的参数类型。（这种情况有可以通过模板来实现）   
直接上例子：  
```c
#include <iostream>  
#include <vector>   
using namespace std;   

//同一个名字的函数，重载了三个版本，分别针对2个参数的int类型，doble类型以及一个参数的vector结构。   
int add(int a, int b)  
{   
	return a + b;  
}    

double add(double a, double b)  
{  
	return a + b;   
}   

int add(vector<int> vec)   
{  
	int que = 0;  
	int num = vec.size();   
	for (int i = 0; i < num; i++)   
	{ 
		que += vec[i];   
	}   
	return que;   
}   
int main()    
{  
	cout << add(1, 2) << endl;//调用了第一种重载函数     
	cout << add(1.4, 1.5) << endl;//调用了第二种重载函数    
	vector<int> abc = { 1,2,3,4,5 };//调用了第三种重载函数     
	cout << add(abc) << endl;   
	getchar();  
	return 0;  
}  
```   
注意：   
1 如果传入的参数与所有的重载函数都不符，编译器找不到可以匹配的会报错。    
2 **是否重载是以参数为特征标记的，如果返回值不同但是参数相同，则不构成重载。**   
3 相同类型与其引用被认为是相同的特征标记，不会引发重载。   
4 const对于普通的参数是无效的，不能引发重载；但是对于指针和引用是有效的，可以引发重载。   
5 虚函数也可以引发重载。       
6 只有在同一个类内的函数才能引发重载。     
7 处于继承关系，即基类和派生类名称相同，但参数不同的函数，无法引发重载。因为在继承关系中，对同名函数的处理，是隐藏基类的同名函数，而不是一般的“根据参数特征标生成不同的重载函数”的处理。       
