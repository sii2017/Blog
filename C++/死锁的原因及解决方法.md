## 死锁
死锁问题被认为是线程/进程间切换消耗系统性能的一种极端情况。   
在死锁时，线程/进程间相互等待资源，而又不释放自身的资源，导致无穷无尽的等待，其结果是任务永远无法执行完成。   
> 打个比方，假设有P1和P2两个进程，都需要A和B两个资源，现在P1持有A等待B资源，而P2持有B等待A资源，两个都等待另一个资源而不肯释放资源，就这样无限等待中，这就形成死锁，这也是死锁的一种情况。给死锁下个定义，如果一组进程中每一个进程都在等待仅由该组进程中的其他进程才能引发的事件，那么该组进程是死锁的。
### 产生死锁必要条件
死锁的产生是必须要满足一些特定条件的：    
1.互斥条件：某资源只能被一个进程使用，其他进程请求该资源时，只能等待，知道资源使用完毕后释放资源。    
2.请求和保持条件：程序已经保持了至少一个资源，但是又提出了新要求，而这个资源被其他进程占用，自己占用资源却保持不放。    
3.不剥夺条件：任何一个资源在没被该进程释放之前，任何其他进程都无法对他剥夺占用。    
4.循环等待条件：当发生死锁时，所等待的进程必定会形成一个环路（类似于死循环），造成永久阻塞。   
### 解决方法
**预防死锁**：破坏死锁的四个必要条件中的一个或多个来预防死锁。但不能破坏互斥条件，其他三个都可。    
**避免死锁**：和预防死锁的区别就是，在资源动态分配过程中，用某种方式防止系统进入不安全的状态。    
**检测死锁**：运行时出现死锁，能及时发现死锁，把程序解脱出来。    
**解除死锁**：发生死锁后，解脱进程，通常撤销进程，回收资源，再分配给正处于阻塞状态的进程。     