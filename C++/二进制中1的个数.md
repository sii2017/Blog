## 二进制中1的个数
这是一道算法题，输入一个数字，获取该数字二进制中1的个数。由于第三种方式让我觉得很有趣，因此记录下来。   
一共有三种方式，循序渐进。   
关于二进制相关信息可以参考同目录下《原码反码补码 左移右移》   
### 第一种方式  
第一种方式是，通过将输入的数字与1做与操作。   
1的二进制为0000 0000 0000 0000 0000 0000 0000 0001。   
如果与操作返回的为true，则说明输入的数字的最低位即XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXX1，也是1，不然如果是0则返回false。   
因此如果返回为true则计数加1，然后将输入的数字进行右移，即变成0XXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX。然后继续与1进行与操作，看这一位是否为1。   
由于对于正数来说，右移操作的时候最高为是补进0的，因此在最多右移31次以后，这个输入的数字就变成0了，就结束比较。   
最后返回计数就可以了。   
代码如下：   
```c
int numberof1_1(int n)  
{  
	int ret = 0;  
	while (n)  //当n变成0则停止比较，最多31次  
	{   
		ret++;  
		n = n & (n - 1);  
	}  
	return ret;   
}   
```   
当然这个解决方式的问题也很明显，它只能计算正数中1的数量。  
由于负数在右移的时候，总会在最高为补1，因此无论右移几百次，输入的数字也不会变成0，最终会变成死循环。   
### 第二种方式  
显然上面的解法是有缺陷的，第二种方式是第一种方式的进化版本：不再对输入的数字进行右移，而是对需要进行与操作的1进行左移。   
0000 0000 0000 0000 0000 0000 0000 0001进行左移。   
0000 0000 0000 0000 0000 0000 0000 0010再进行左移。   
0000 0000 0000 0000 0000 0000 0000 0100以此类推。   
每一次都与输入的数字进行比较，无论对正数和负数都是有效的。  
直到32次左移后，1变成了0结束。   
```c 
int numberof1_2(int n)  
{  
	int ret= 0;   
	unsigned int flag = 1;  
	while (flag)  
	{  
		if (flag&n)  
			ret++;   
		flag= flag << 1;  
	}  
	return ret;     
}  
```   
这个方式基本上已经可以解决问题了，不过它也有着缺陷，那就是需要循环32次之多。   
不过如果不是我看到书上写的第三种方式，我基本就是第二种方式了，显然看书还是很有用的，并且很有意思的。   
### 第三种方式  
第三种方式进一步增加了我对二进制数字的理解，之前对二进制数字并不是很重视，忽略了其中的一些特性。   
**当一个数字与其减一后的值进行与操作时，会消除其二进制数字中最右边的一个1。**   
随便取一个数字：1000 0001 1101 1111 1110 0000 1011 1000   
减一后是1000 0001 1101 1111 1110 0000 1011 0111，可以看到减一后只会将最右的一个1变成0，同时右边的所有0变成1。   
当这两个数进行与操作，在最右边的1左边的所有二进制数字由于完全相同不会有改变，而最右的本来是1变成了0，右边本来是0变成了1则因为与操作相互抵消没有了。   
因此第三种方式就是，将这个二进制数字与自己减一的值进行与操作，逐一消除最右的1并计数，整个数字变成0。   
```c
int numberof1_3(int n)  
{  
	int ret = 0;   
	while (n)  
	{  
		ret++;   
		n = n & n - 1;  
	}   
	return ret;  
}   
```   
这也是对正数负数通用的。   
涨知识了。   