## c++线程中的几种锁
线程之间的锁有：**互斥锁、条件锁、自旋锁、读写锁、递归锁。**     
一般而言，锁的功能越强大，性能就会越低。   
### 互斥锁
互斥锁用于控制多个线程对他们之间共享资源互斥访问的一个信号量。也就是说是为了避免多个线程在某一时刻同时操作一个共享资源。   
在某一时刻，只有一个线程可以获取互斥锁，在释放互斥锁之前其他线程都不能获取该互斥锁。如果其他线程想要获取这个互斥锁，那么这个线程只能以阻塞方式进行等待。   
比如自己有一坨钱，但是支付宝也好，微信也好，必须依次去访问它，不能出现同时扣钱或者同时存钱，不然数额就会不准确。因此建立一个锁，当支付宝在进行操作的时候，微信钱包就不能进行操作。   
```c
#include <windows.h>   
#include <stdio.h>   
#include <process.h>  
using namespace std;  

int total_money= 100000;   
HANDLE hMutex;   
 
//支付宝  
unsigned int _stdcall Thread1(PVOID param)  
{  
	while(1)   
	{  
		WaitForSingleObject(hMutex,INFINITE);   
		char buff[256];  
		total_money-=12;   
		sprintf(buff, "支付宝买一点点奶茶花掉了12块钱，还剩%d", total_money);   
		printf("%s\n", buff);  
		ReleaseMutex(hMutex);  

		if(total_money<=0)   
			break;   

		Sleep(2000);  
	}  
	return 1;  
}  
   
//微信钱包   
unsigned int _stdcall Thread2(PVOID param)  
{  
	while(1)  
	{   
		WaitForSingleObject(hMutex,INFINITE);  
		char buff[256];  
		total_money-=3;   
		sprintf(buff, "微信钱包买鲜肉月饼花掉了3块钱，还剩%d", total_money); 
		printf("%s\n", buff);  
		ReleaseMutex(hMutex);   
 
		if(total_money<=0)   
			break;  

		Sleep(5000);  
	}   
	return 1;  
} 

//交通银行   
unsigned int _stdcall Thread3(PVOID param)  
{  
	while(1)   
	{   
		WaitForSingleObject(hMutex,INFINITE);  
		char buff[256];  
		total_money+=10;   
		sprintf(buff, "交通银行发工资10块钱，还剩%d", total_money);   
		printf("%s\n", buff);  
		ReleaseMutex(hMutex);  
   
		if(total_money<=0)  
			break;   

		Sleep(15000);  
	}  
	return 1;  
}  
  
//交通银行里的理财   
unsigned int _stdcall Thread4(PVOID param)   
{   
	while(1) 
	{  
		WaitForSingleObject(hMutex,INFINITE);  
		char buff[256];  
		total_money-=500;  
		sprintf(buff, "交通银行理财扣掉500，还剩%d", total_money);   
		printf("%s\n", buff);   
		ReleaseMutex(hMutex); 

		if(total_money<=0)   
			break;  

		Sleep(15000);    
	}  
	return 1; 
}  
  
//炒股票  
unsigned int _stdcall Thread5(PVOID param)   
{  
	while(1)   
	{  
		WaitForSingleObject(hMutex,INFINITE);  
		char buff[256];  
		total_money-=1000;   
		sprintf(buff, "炒股票血亏1000，还剩%d", total_money);    
		printf("%s\n", buff);  
		ReleaseMutex(hMutex);  

		if(total_money<=0)   
			break;  

		Sleep(20000);  
	}   
	return 1;  
}   

int main()   
{  
	HANDLE handle[5];   
	hMutex= CreateMutex(NULL,FALSE,NULL);  
	for(int i=0;i <5; i++)  
	{  
		char buff[256];  
		switch(i)  
		{  
		case 0:  
			handle[i]= (HANDLE)_beginthreadex(NULL, 0, Thread1, buff, 0, NULL);  
			break;  
		case 1:   
			handle[i]= (HANDLE)_beginthreadex(NULL, 0, Thread2, buff, 0, NULL);  
			break;  
		case 2:   
			handle[i]= (HANDLE)_beginthreadex(NULL, 0, Thread3, buff, 0, NULL);  
			break;  
		case 3: 
			handle[i]= (HANDLE)_beginthreadex(NULL, 0, Thread4, buff, 0, NULL);  
			break; 
		case 4:   
			handle[i]= (HANDLE)_beginthreadex(NULL, 0, Thread5, buff, 0, NULL); 
			break;   
		}  
	}   

	for(int i=0;i<5;i++)  
	{  
		CloseHandle(handle[i]);  
	}  

	getchar();  
	return 0;   
}  
```  
### 条件锁